<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>读设计模式之禅</title>
    <url>/2020/09/14/%E8%AF%BB%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85/</url>
    <content><![CDATA[<h1 id="读设计模式之禅笔记"><a href="#读设计模式之禅笔记" class="headerlink" title="读设计模式之禅笔记"></a>读设计模式之禅笔记</h1><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>​        接口一定要做到单一职责<strong>(即接口只用来做一件事)</strong>，类的设计尽量做到只有一个原因引起变化<strong>(即只有一个原因才会使这个类的属性发生变化)。</strong></p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>​        里氏替换原则是继承复用的基石，只有<strong>当衍生类可以替换基类，软件单位的功能不受到影响</strong>时，即<strong>基类随便怎么改动子类都不受此影响，那么基类才能真正被复用。</strong></p>
<p>​        因为继承带来的侵入性，增加了耦合性，也降低了代码灵活性，父类修改代码，子类也会受到影响，此时就需要里氏替换原则。</p>
<p>​        只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，但是反过来就不行，子类出现的地方父类不一定可以出现，即向下转型是不安全的。</p>
<p>​        比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Father f = <span class="keyword">new</span> Father();</span><br></pre></td></tr></table></figure>

<p>​        替换为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Son f = <span class="keyword">new</span> Son();</span><br></pre></td></tr></table></figure>

<p>其中Son是Father的子类。</p>
<p>​        如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生了“畸变”，则建议断开父子继承关系，采用<strong>依赖、聚集、组合</strong>等关系代替继承。</p>
<h3 id="四个注意点"><a href="#四个注意点" class="headerlink" title="四个注意点"></a>四个注意点</h3><p>​        <strong>1、子类必须实现父类的抽象方法，但不得重写（注意是重写，不是重载）父类的非抽象（已实现）方法。</strong></p>
<p>​                父类的抽象方法，没有在父类中实现，子类可以实现。但是父类的非抽象方法，即已经实现过的方法，子类不得<strong>重写</strong>（前置参数            相同，即方法的参数相同，但方法内容不同）。因为重写之后，子类调用方法时，只会调用子类重写父类之后的方法，而不会调用            父类的方法。</p>
<p>​        <strong>2、子类中可以增加自己特有的方法。</strong></p>
<p>​                子类增加自己特有的方法，不会影响父类，属于子类的个性。</p>
<p>​        <strong>3、子类中方法的前置条件（方法形参）要比父类中被覆写的方法的前置条件更宽松。</strong></p>
<p>​                这里的前置条件更宽松，指的是子类中的方法的前置条件，与父类中相同方法的前置条件不同，且子类的前置条件类型更宽更            大，这就意味着是对父类方法的<strong>重载</strong>，则父类调用方法的时候的参数，给子类的方法调用，还是会调用父类的方法。这相当于子类            调用从父类中继承下来的父类的方法，因此父类和子类替换，不会影响程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(HashMap map)</span></span>&#123;</span><br><span class="line">    	System.out.print(<span class="string">"父类方法被执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Map map)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"子类方法被执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        HashMap&lt;Object, Object&gt; map=<span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line">        <span class="comment">//执行父类方法</span></span><br><span class="line">        System.out.print(<span class="string">"执行父类方法"</span>);</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.fun(map);</span><br><span class="line">        <span class="comment">//父类存在的地方，可以用子类替代</span></span><br><span class="line">        <span class="comment">//子类B替代父类A</span></span><br><span class="line">        System.out.print(<span class="string">"子类代替父类后运行"</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">       	b.fun(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​        <strong>4、当子类实现父类的抽象方法时，方法的后置条件(即方法的返回值)要比父类更严格。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Map <span class="title">fun</span><span class="params">()</span></span>;            <span class="comment">//父类抽象方法返回值是Map</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;   <span class="comment">//B继承A</span></span><br><span class="line">    <span class="comment">//B实现A的抽象方法,返回值类型比父类方法严格</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HashMap <span class="title">fun</span><span class="params">()</span></span>&#123;                         <span class="comment">//子类实现父类抽象方法返回值是HashMap,比父类返回值严格</span></span><br><span class="line">        HashMap b = <span class="keyword">new</span> HashMap();</span><br><span class="line">        b.put(<span class="string">"b"</span>, <span class="string">"子类被执行..."</span>);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> B();</span><br><span class="line">        a.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    若在继承时，子类的方法返回值类型范围比父类的方法返回值类型范围大，在子类重写该方法时编译器会报错。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ajax遇到的问题</title>
    <url>/2020/08/14/%E4%BD%BF%E7%94%A8ajax%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="使用ajax遇到的问题"><a href="#使用ajax遇到的问题" class="headerlink" title="使用ajax遇到的问题"></a>使用ajax遇到的问题</h1><h2 id="一、安装Jquery"><a href="#一、安装Jquery" class="headerlink" title="一、安装Jquery"></a>一、安装Jquery</h2><p>这里使用Jquery的ajax，在html文件中，要加入Jquery，需要在<head></head>部位加上下面这句：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>若是没有下载此包，使用ctrl + 鼠标左键点击此链接，然后下载即可。</p>
<h2 id="二、pom-xml依赖"><a href="#二、pom-xml依赖" class="headerlink" title="二、pom.xml依赖"></a>二、pom.xml依赖</h2><p>由于Ajax与后端Controller通过json传递数据，所以需要引用json的依赖，如下所示:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 6. json包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在applicationContext.xml中加入如下的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、在html文件中添加css"><a href="#三、在html文件中添加css" class="headerlink" title="三、在html文件中添加css"></a>三、在html文件中添加css</h2><p>在html头部<head></head>中添加如下语句：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/login.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中href填入的是相对地址或者是绝对地址。</p>
<h2 id="四、Ajax无法进入Controller控制台"><a href="#四、Ajax无法进入Controller控制台" class="headerlink" title="四、Ajax无法进入Controller控制台"></a>四、Ajax无法进入Controller控制台</h2><p>html中的ajax如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">                    type: "post",</span><br><span class="line">                    url: "http://localhost:8080/project_war_exploded/user/login",</span><br><span class="line">                    dataType: "json",//注意使用的是打他dataType，而不是Content-Type</span><br><span class="line">                    async: true,</span><br><span class="line">                    data: &#123;stu_id: null, stu_name: null, username: name, password: pwd&#125;,</span><br><span class="line">                    success: function (data) &#123;</span><br><span class="line">                        if (data.username == "error") &#123;</span><br><span class="line">                            alert("密码错误！")</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            window.location.href = "../pages/success.jsp";</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    error: function (data) &#123;</span><br><span class="line">                        alert("进入错误界面")</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>

<p>原来的url直接是user/login，但是突然不能进入控制台，后来将url改成了<strong>控制台页面的全部url</strong>，即加上前缀的url：<a href="http://localhost:8080/project_war_exploded/user/login，就可以进入了。" target="_blank" rel="noopener">http://localhost:8080/project_war_exploded/user/login，就可以进入了。</a></p>
<h2 id="五、设置WEB工程的初始页面"><a href="#五、设置WEB工程的初始页面" class="headerlink" title="五、设置WEB工程的初始页面"></a>五、设置WEB工程的初始页面</h2><p>在配置Tomcat的地方设置初始url，如下所示：</p>
<p><img src="/2020/08/14/%E4%BD%BF%E7%94%A8ajax%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/1.jpg" alt></p>
<p>改成初始页面的url，运行服务器时就会首先显示这个页面。</p>
<h2 id="六、ajax无法收到Controller的返回值"><a href="#六、ajax无法收到Controller的返回值" class="headerlink" title="六、ajax无法收到Controller的返回值"></a>六、ajax无法收到Controller的返回值</h2><p>有可能是数据库没有启动，打开数据库发现不能连接。</p>
<p><strong>解决方法</strong>：</p>
<p>​        打开windows键-&gt;服务-&gt;MySQL-&gt;右键开启</p>
<p>打开服务后，即可连接数据库，ajax与Controller即可连接成功。</p>
<h2 id="七、Ajax接收到Controller返回的类是空数据"><a href="#七、Ajax接收到Controller返回的类是空数据" class="headerlink" title="七、Ajax接收到Controller返回的类是空数据"></a>七、Ajax接收到Controller返回的类是空数据</h2><p>原因：</p>
<p>​        <strong>Controller返回的类，没有添加get()方法</strong>，使得Ajax无法提取返回的类对象的信息，当添加get()方法之后，就可以成功的获取到Controller返回的类对象。</p>
<h2 id="八、使用cookie方法"><a href="#八、使用cookie方法" class="headerlink" title="八、使用cookie方法"></a>八、使用cookie方法</h2><p>需要调用Jquery以及cookie.js包，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/jquery/3.4.0/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/jquery-cookie/1.4.1/jquery.cookie.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体使用方法，查看菜鸟教程 Jquery cookie插件：</p>
<p><a href="https://www.runoob.com/jquery/jquery-cookie-plugin.html" target="_blank" rel="noopener">https://www.runoob.com/jquery/jquery-cookie-plugin.html</a></p>
<h2 id="九、进入Ajax函数"><a href="#九、进入Ajax函数" class="headerlink" title="九、进入Ajax函数"></a>九、进入Ajax函数</h2><p>若是没有click点击事件进入Ajax函数，可以直接使用$(document).ready(function() {}的语法。</p>
<p>如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    type: <span class="string">"post"</span>,</span><br><span class="line">                    url: <span class="string">"http://localhost:8080/project_war_exploded/home.do"</span>,</span><br><span class="line">                    dataType: <span class="string">"json"</span>,</span><br><span class="line">                    success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">                        alert(res)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    error: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        alert(<span class="string">"进入错误界面"</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>

<p>不要使用html的<strong>on load</strong>属性，因为使用了它进入Ajax函数时会很慢，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">on</span> <span class="attr">load</span> = <span class="string">"function()"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>测试类的使用</title>
    <url>/2020/08/10/%E6%B5%8B%E8%AF%95%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="测试类的使用"><a href="#测试类的使用" class="headerlink" title="测试类的使用"></a>测试类的使用</h1><p>首先要使用Test，pom.xml要包含依赖如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果junit包不能导入，则需要在File-&gt;Project Structure-&gt;librariies中添加junit-4.12.jar。</p>
<p>导入jar包之后，有三个注解可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="meta">@Test</span></span><br></pre></td></tr></table></figure>

<p><strong>@RunWith</strong></p>
<p>在搭建SSM的时候，假如要单独测试Spring或者测试SpringMVC与Spring是否连接时，需要用到，<strong>放在类名的上面</strong>，用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure>

<p><strong>@ContextConfiguration</strong></p>
<p>配置Spring的时候，肯定要选择一个Spring的xml配置文件，这时就需要用到这个注解，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(value = <span class="string">"classpath:applicationContext.xml"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>@Test</strong></p>
<p>此注解放在方法的上面，使得此类不需要main()函数，就可以直接运行这个方法。</p>
<p>下面举几个例子：</p>
<p>1、TestSpring（用来测试Spring）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)  //加载<span class="title">spring</span>环境</span></span><br><span class="line">@ContextConfiguration("classpath:applicationContext.xml")  //读取Spring配置，创建IOC容器</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userService.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、TestMyBatis（用来单独测试MyBatis）</p>
<p>由于此测试类只测试MyBatis，不加载Spring，所有前两个注解不使用，只使用@Test</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyBatis</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 加载SqlMapConfig.xml</span></span><br><span class="line">        InputStream in = Resources.getResourceAsStream(<span class="string">"sqlMapConfig.xml"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 创建SqlSessionFactory</span></span><br><span class="line">        SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory factory = builder.build(in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 创建SqlSession</span></span><br><span class="line">        SqlSession sqlSession = factory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 创建Dao代理对象</span></span><br><span class="line">        UserDao accountDao = sqlSession.getMapper(UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 执行方法</span></span><br><span class="line">        List&lt;User&gt; list = accountDao.findAll();</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、TestSpringMyBatis（测试Spring和MyBatis的整合）</p>
<p>由于要测试Spirng和MyBatis是否整合成功，所有必须加上前两个注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">value</span> </span>= <span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpringMyBatis</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从容器中获取业务实现</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(userService.findAll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>整合SSM</title>
    <url>/2020/08/10/%E6%95%B4%E5%90%88SSM/</url>
    <content><![CDATA[<h1 id="整合SSM"><a href="#整合SSM" class="headerlink" title="整合SSM"></a>整合SSM</h1><p>pom.xml依赖如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.spring相关依赖 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.1 ioc --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.2 aop --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.3 声明式事务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.4 test --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. mybatis相关依赖 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2.1 mysql驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2.2 连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2.3 mybatis核心包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3. springmvc相关依赖 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3.1 springmvc核心包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3.2 servlet依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3.3 jstl标签库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4. log4j日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 5. spring与mybatis整合包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>applicationContext.xml以及springmvc.xml<strong>头部的检验</strong>，要补充完全，复制过去即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:contex</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>applicationContext.xml举例如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:contex</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans 		   http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描Service实现类——将service类在IOC容器中创建bean对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contex:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.service"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将MyBatis与Spring整合的配置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 创建数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contex:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:jdbc.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 为了创建Dao代理对象，先创建SqlSessionFactory对象 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  SqlSessionFactoryBean: 创建SqlSessionFactory对象的工具 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 加载接口 mapper 配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3. 扫描Dao接口所在包，扫描后用于创建Dao代理对象，把代理点对象放入IOC容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Dao扫描目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意2中的加载接口的Mapper配置文件，必须要加上</strong></p>
<p>resource中的jdbc.properties文件如下所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.url</span> = <span class="string">jdbc:mysql://localhost:3306/ssm?characterEncoding=utf8</span></span><br><span class="line"><span class="meta">jdbc.driver</span> = <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.username</span> = <span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span> = <span class="string">a1210080212</span></span><br></pre></td></tr></table></figure>

<p>springmvc.xml如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:contex</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans 		   http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 打开Controller包的扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contex:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.Controller"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">     <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/pages/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>web.xml如下图所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- web.xml各个模块排放的位置有规定，不然会报错 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 加载applicationContext.xml（初始化SpringIOC容器） --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 过滤器，防止输入表单中文数据变为乱码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- SpringMVC和Sping相联系的监听器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Controller<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Controller<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>（注意：不论写多少个Controller，web.xml只需要写一个servlet即可，即dispatcherServlet。）</strong></p>
<p>其中，<strong>Springmvc与Spring整合</strong>的关键部分，就是<strong>在web.xml中加入监听器</strong>，如上图中的最上方部分：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置spring监听器，用于加载applicationContext.xml（初始化SpringIOC容器） --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>接口的Mapper.xml文件</strong>，例子如下所示：</p>
<p>loginDaoMapper.xml如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.dao.LoginDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"loginUserResultMap"</span> <span class="attr">type</span>=<span class="string">"com.pojo.LoginUser"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"studentId"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"studentId"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"studentName"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"studentName"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- resultType即返回的对象的类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findLoginUser"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span> <span class="attr">resultType</span>=<span class="string">"String"</span>&gt;</span></span><br><span class="line">        select studentId from login where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>resultMap</strong>是指经过SQL语句返回的一个类对象结构，可以是几个表联合查询后的类。而<strong>type</strong>需要填pojo文件夹的对应类。</p>
<p>上述例子中，<strong>id</strong>和<strong>result</strong>后面的<strong>column</strong>的值代表了<strong>Sql表中的字段</strong>，其中id是主键，同时后面的<strong>property</strong>是指<strong>sql对应的返回类对象中的成员变量</strong>。</p>
<p><strong>或者可以不写resultMap，直接引用pojo文件夹中的类，但是此类的成员变量要与数据库中字段相同</strong>，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.dao.CourseDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"showCourse"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span> <span class="attr">resultType</span>=<span class="string">"com.pojo.Course"</span>&gt;</span></span><br><span class="line">        select * from course where studentId = #&#123;studentId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>整合SSM遇到的问题</title>
    <url>/2020/08/09/%E6%95%B4%E5%90%88SSM%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="整合SSM时遇到的问题"><a href="#整合SSM时遇到的问题" class="headerlink" title="整合SSM时遇到的问题"></a>整合SSM时遇到的问题</h1><h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><p>编写测试类时，程序如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)  //加载<span class="title">spring</span>环境</span></span><br><span class="line">@ContextConfiguration("classpath:applicationContext.xml")  //读取Spring配置，创建IOC容器</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userService.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始时<strong>import org.junit.Test;</strong>和<strong>import org.junit.runner.RunWith;</strong>语句都不起作用，但是pom.xml依赖里已经添加了junit，如下所示，但不起作用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时需要在File-&gt;Project Structure-&gt;libraries里添加junit.jar，点击+，然后在maven/LocalWarehouse里找，如下图所示：</p>
<p><img src="/2020/08/09/%E6%95%B4%E5%90%88SSM%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/1.jpg" alt></p>
<p>导入完之后那两个import语句就会出现。但是<strong>@RunWith(SpringJUnit4ClassRunner.class)</strong>会出现错误，这时错误原因是它需要junit-4.12即以上，此时<strong>把pom.xml以及libraries的导入jar改成4.12或以上版本</strong>即可。</p>
<p>还有个疑问就是<strong><scope>test</scope></strong>需不需要去掉，这里好像将版本改成4.12之后就不能添加此语句，否则使用mvn clean package语句就会报错。</p>
<h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><p>我的serviceImpl类忘记继承了service接口，当给serviceImpl使用注解@Service时，不能创建bean实例到IOC容器里，一定不要漏掉接口，如下图所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查询所有用户..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，需要在applicationContext.xml文件中，既要扫描此service类的包，又要开启驱动</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 扫描Service实现类 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">contex:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.service"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时，上面的url地址要写全，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:contex</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans 		   http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><p>controller类里使用<strong>model.addAttribute(“list”, “用户数据”);</strong>语句，在jsp文件中使用EL表达式<strong>${list}</strong>，不能进行数据显示，这时需要在jsp文件中补充&lt;%@ page isELIgnored=”false” %&gt;，如下所示：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ page isELIgnored=<span class="string">"false"</span> %&gt;</span><br></pre></td></tr></table></figure>

<h2 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h2><p>整合springmvc和spring时失败，是因为在web.xml中的<servlet></servlet>前添加了如下语句后：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置spring监听器，用于加载applicationContext.xml（初始化SpringIOC容器） --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>没有添加<strong>listen监听器</strong>，正常应该在下面添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置spring监听器，用于加载applicationContext.xml（初始化SpringIOC容器） --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加完成之后，Controller控制台即可成功从Spring IOC容器注入Service，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span>    <span class="comment">//从Spring IOC容器自动注入userService对象</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询所有用户</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        <span class="comment">//调用业务层方法</span></span><br><span class="line">        userService.findAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存入数据到request域</span></span><br><span class="line">        model.addAttribute(<span class="string">"list"</span>, <span class="string">"用户数据"</span>);</span><br><span class="line">        <span class="comment">//返回list.jsp页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"list"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、"><a href="#五、" class="headerlink" title="五、"></a>五、</h2><p>SqlMapConfig.xml配置文件的头部分，它与applicationContext.xml文件和springmvc文件都不同。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="六、"><a href="#六、" class="headerlink" title="六、"></a>六、</h2><p>首先myBatis连接时，pom.xml文件的依赖里，druid是需要加上的，这其实就是连接池的依赖包，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 2.2 数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时，更重要的是，连接数据库的总配置文件sqlMapConfig.xml中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 读取jdbc.properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"jdbc.properties"</span>/&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2. 数据库连接 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"jdbc"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"pooled"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>四个属性放在jdbc.properties中，如下所示</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.url</span> = <span class="string">jdbc:mysql://localhost:3306/ssm?characterEncoding=utf8</span></span><br><span class="line"><span class="meta">jdbc.driver</span> = <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.username</span> = <span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span> = <span class="string">a1210080212</span></span><br><span class="line"><span class="meta">jdbc.initialSize</span> = <span class="string">3</span></span><br><span class="line"><span class="meta">jdbc.maxActive</span> = <span class="string">10</span></span><br></pre></td></tr></table></figure>

<p><strong>其中关系着连接哪个数据库的，是url中的3306/后面的名字</strong>，上面所述连接的数据库是ssm。</p>
<h2 id="七、"><a href="#七、" class="headerlink" title="七、"></a>七、</h2><p>在使用<strong>@Component、@Repository、@Service、@Controller</strong>等注解时，如果发现@Autowired自动注入失败，就要去找一找applicationContext.xml文件中，对应的包有没有加入注解扫描。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 扫描Service实现类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contex:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.service"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contex:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.pojo"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里扫描了service包，同时也扫描了pojo包，这样这两个包中加入了注解的类就会自动创建bean对象放到Spring IOC容器里。</p>
<h2 id="八"><a href="#八" class="headerlink" title="八"></a>八</h2><p>插入数据时，出现如下错误：</p>
<p>Cause: com.mysql.jdbc.MysqlDataTruncation: Data truncation: Data too long for column ‘sex’ at row 1</p>
<p><img src="/2020/08/09/%E6%95%B4%E5%90%88SSM%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/2.jpg" alt></p>
<p>这个意思是，创建数据库时，设置的字段长度太短了，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">   <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">   <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名称'</span>,</span><br><span class="line">   <span class="string">`sex`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'性别'</span>,</span><br><span class="line">   <span class="string">`address`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'地址'</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line"> ) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">49</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure>

<p>上述的sex字段太短了，如果表单提交的是’男’或‘女’数据，会报上述的错误，创建表单时改长即可：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">   <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">   <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名称'</span>,</span><br><span class="line">   <span class="string">`sex`</span> <span class="built_in">varchar</span>(<span class="number">12</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'性别'</span>,</span><br><span class="line">   <span class="string">`address`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'地址'</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line"> ) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">49</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure>

<h2 id="九、"><a href="#九、" class="headerlink" title="九、"></a>九、</h2><p>提交表单数据是中文时，数据库添加的是乱码。</p>
<p><strong>解决方法</strong>：</p>
<p>​        在web.xml中添加如下过滤器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>web.xml中各个不同部分，添加的位置有规定，不按规定会报错。</strong>web.xml如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- web.xml各个模块排放的位置有规定，不然会报错 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 加载applicationContext.xml（初始化SpringIOC容器） --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 过滤器，使提交的表单数据不出现乱码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- SpringMVC和Sping相联系的监听器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>UserController<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>UserController<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="十、"><a href="#十、" class="headerlink" title="十、"></a>十、</h2><p>使用注解来代替MyBatis的mapper.xml文件，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询所有用户</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入用户数据</span></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into user (id,username,sex,address) values(#&#123;id&#125;, #&#123;username&#125;, #&#123;sex&#125;, #&#123;address&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过id删除一个用户</span></span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">"delete from user where id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeleteUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在加入一个通过id修改用户信息的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Update</span>(<span class="string">"update user set address = #&#123;address&#125; where id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateAddressById</span><span class="params">(String address, Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>提交表单信息id和address，发现出错，如下所示：</p>
<p><img src="/2020/08/09/%E6%95%B4%E5%90%88SSM%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/3.jpg" alt></p>
<p>报错信息为：org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.binding.BindingException: Parameter ‘address’ not found. Available parameters are [arg1, arg0, param1, param2]</p>
<p>这是因为<strong>表单提交的数据与pojo对象的参数顺序不同</strong>，我们来看pojo包的User类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", sex='"</span> + sex + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺序是id、username、sex、address，而我们只是提供id和address的表单数据，跳过了username和sex，导致sql语句出错：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> address = <span class="comment">#&#123;address&#125; where id = #&#123;id&#125;</span></span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<p>​        使用@Param注解，标明输入的这个参数是代表哪个成员变量，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Update</span>(<span class="string">"update user set address = #&#123;address&#125; where id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateAddressById</span><span class="params">(@Param(<span class="string">"address"</span>)</span> String address, @<span class="title">Param</span><span class="params">(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br></pre></td></tr></table></figure>

<p>这样就代表address这个变量代表的是address这个参数，id这个变量代表的是id这个参数。</p>
<h2 id="十一、"><a href="#十一、" class="headerlink" title="十一、"></a>十一、</h2><p>在resource文件夹创建第一个applicationContext.xml文件的时候，新建xml文件，不能创建Spring Config文件。这时，我们通过直接输入applicationContext.xml的名字创建file的方式，来创建一个Spring Config文件，并且把另一个项目的applicationContext.xml文件的头部复制过去，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:contex</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans 		   http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>出现了如下错误：</p>
<p><strong>Application Context not configured for this file</strong></p>
<p>解决方法：</p>
<p>​        <strong>file-&gt;Project Structure-&gt;Modules-&gt;选择Spring-&gt;右边+号-&gt;添加applicationContext.xml-&gt;应用。</strong></p>
<p>这时，就可以创建Spring Config文件了，此时我们删除原来的applicationContext.xml，重新创建一个即可。</p>
<h2 id="十二、IDEA修改包名"><a href="#十二、IDEA修改包名" class="headerlink" title="十二、IDEA修改包名"></a>十二、IDEA修改包名</h2><p>IDEA修改包名后，运行服务器会出错，这是因为target里的project-&gt;WEB-INF-&gt;classes里的包名还没有改变。</p>
<p><strong>解决方法</strong>:</p>
<p>​        <strong>删除target文件，然后重新运行服务器即可</strong>，此时会重新生成一个target文件夹。</p>
<h2 id="十三、更改静态文件后，运行服务器没发生变化"><a href="#十三、更改静态文件后，运行服务器没发生变化" class="headerlink" title="十三、更改静态文件后，运行服务器没发生变化"></a>十三、更改静态文件后，运行服务器没发生变化</h2><p>这是因为，网页上之前<strong>静态页面有缓存</strong>，导致显示没有发生变化。</p>
<p>两处更改：</p>
<p>​        1: Run –&gt; Edit Configurations –&gt; On Update option 和 On Frame Deactivation 都选 Update classes and resources</p>
<p>​        2: Chrome-&gt;F12-&gt;Network-&gt;Disable cache（清除缓存）</p>
<p>第一处更改的是否需要，还不清楚，但是清除完缓存之后即可正常显示。</p>
<h2 id="十四、web-xml中的url-pattern问题"><a href="#十四、web-xml中的url-pattern问题" class="headerlink" title="十四、web.xml中的url-pattern问题"></a>十四、web.xml中的url-pattern问题</h2><p>遇到的一个bug：</p>
<p>web.xml中的<strong><servlet-mapping></servlet-mapping></strong>,第一个<strong><url-pattern></url-pattern></strong>必须是 <strong>/*</strong>，否则，进入不了它的Controller</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginController<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>CourseController<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>UserController<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/.co<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="十五、运行服务器之后，出现初始界面但没反应"><a href="#十五、运行服务器之后，出现初始界面但没反应" class="headerlink" title="十五、运行服务器之后，出现初始界面但没反应"></a>十五、运行服务器之后，出现初始界面但没反应</h2><p>这可能是MySQL数据库没有启动，导致服务器没办法连接到数据库</p>
<p><strong>解决办法：</strong></p>
<p>​        窗口键-&gt;服务-&gt;MySql-&gt;右键启动</p>
<p>打开后，即可成功连接数据库。</p>
<h2 id="十六、web-xml中的Servlet设置"><a href="#十六、web-xml中的Servlet设置" class="headerlink" title="十六、web.xml中的Servlet设置"></a>十六、web.xml中的Servlet设置</h2><p>不论写多少个Controller，web.xml只需要写一个servlet，即DispatcherServlet，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Controller<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:Controller-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Controller<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="十七、Sesson设置"><a href="#十七、Sesson设置" class="headerlink" title="十七、Sesson设置"></a>十七、Sesson设置</h2><p>只需在Controller接口函数的参数里加上<strong>HttpServletRequest  request</strong>，即可获取sesson的值或者设置sesson的值。</p>
<p>如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/home"</span>)</span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ServerResponse&lt;User&gt; <span class="title">getUserById</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取sesson</span></span><br><span class="line">       String studentId = (String) request.getSession(<span class="keyword">true</span>).getAttribute(<span class="string">"studentId"</span>);</span><br><span class="line"></span><br><span class="line">       User user = userService.getUserById(studentId);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> ServerResponse.createSuccessResponse(user);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>设置sesson:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getSession(<span class="keyword">true</span>).setAttribute(<span class="string">"studentId"</span>, username);</span><br></pre></td></tr></table></figure>

<p>获取sesson：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String studentId = (String) request.getSession(<span class="keyword">true</span>).getAttribute(<span class="string">"studentId"</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建MyBatis遇到的问题</title>
    <url>/2020/08/05/%E6%90%AD%E5%BB%BAMyBatis%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="搭建MyBatis遇到的问题"><a href="#搭建MyBatis遇到的问题" class="headerlink" title="搭建MyBatis遇到的问题"></a>搭建MyBatis遇到的问题</h1><h2 id="一、MySQL依赖文件添加"><a href="#一、MySQL依赖文件添加" class="headerlink" title="一、MySQL依赖文件添加"></a>一、MySQL依赖文件添加</h2><p>pom.xml文件添加mysql-connector-java、mybatis、log4j的依赖时，版本号始终为红色字体，并显示<strong>Dependency ‘mysql:mysql-connector-java:5.1.46’ not found</strong> 等信息。</p>
<p>解决办法：</p>
<p>​        不需要更换版本号，只需要右键项目，点击maven，然后Reload Project即可，如下图所示：</p>
<p><img src="/2020/08/05/%E6%90%AD%E5%BB%BAMyBatis%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/1.jpg" alt></p>
<p>重载工程完成后，版本号就变为蓝色，如下所示：</p>
<p><img src="/2020/08/05/%E6%90%AD%E5%BB%BAMyBatis%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/2.jpg" alt></p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建SpringMVC遇到的问题</title>
    <url>/2020/08/04/%E6%90%AD%E5%BB%BASpringMVC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="搭建SpringMVC遇到的问题"><a href="#搭建SpringMVC遇到的问题" class="headerlink" title="搭建SpringMVC遇到的问题"></a>搭建SpringMVC遇到的问题</h1><p>根据网上的教程，使用IDEA和maven搭建了一个SpringMVC的demo，创建了一个Controller类，一个springmvc2.xml文件，web.xml文件，以及一个跳转页面success.jsp，success.jsp放在了webapp/jsp文件夹里。</p>
<h2 id="运行程序后，在网页上输入控制器-Controller类-的地址，出现500的错误"><a href="#运行程序后，在网页上输入控制器-Controller类-的地址，出现500的错误" class="headerlink" title="运行程序后，在网页上输入控制器(Controller类)的地址，出现500的错误"></a>运行程序后，在网页上输入控制器(Controller类)的地址，出现500的错误</h2><p>我的Controller类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入控制输出"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>springmvc2.xml文件如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:contex</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contex:component-scan</span> <span class="attr">base-package</span>=<span class="string">"Controller"</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 开启后自动注册处理器适配器和处理器映射,必须要使用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>web.xml文件如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc2<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc2.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc2<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当运行程序时，由于工程一开始带有的index.jsp，弹出了一个页面，url是：<a href="http://localhost:8080/TestSpringMVC_war_exploded/，如下图所示：" target="_blank" rel="noopener">http://localhost:8080/TestSpringMVC_war_exploded/，如下图所示：</a></p>
<p><img src="/2020/08/04/%E6%90%AD%E5%BB%BASpringMVC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/2.jpg" alt></p>
<p>跟据我的Controller控制器和springmvc2.xml文件，我输入一个新的url：<a href="http://localhost:8080/TestSpringMVC_war_exploded/hello.do，根据上述文件，正常应该会跳入页面：http://localhost:8080/TestSpringMVC_war_exploded/jsp/success.jsp，并显示success.jsp的内容，但是并没有，它出错了，出现了500错误，如下图所示" target="_blank" rel="noopener">http://localhost:8080/TestSpringMVC_war_exploded/hello.do，根据上述文件，正常应该会跳入页面：http://localhost:8080/TestSpringMVC_war_exploded/jsp/success.jsp，并显示success.jsp的内容，但是并没有，它出错了，出现了500错误，如下图所示</a>:</p>
<p><img src="/2020/08/04/%E6%90%AD%E5%BB%BASpringMVC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/3.jpg" alt></p>
<p>查看其中根本原因如下：</p>
<p><strong>Line 16 in XML document from class path resource [springmvc2.xml] is invalid</strong></p>
<p>意思是读取springmvc2.xml读取失败，继续往后看，发现：</p>
<p><strong>通配符的匹配很全面, 但无法找到元素 ‘contex:component-scan’ 的声明。</strong> </p>
<p>或者是</p>
<p><strong>通配符的匹配很全面, 但无法找到元素 ‘mvc:annotation-driven’ 的声明。</strong></p>
<p>这两种错误是由于springmvc2.xml文件创建时自动产生的xmlns和xsi:schemaLocation不合适，使得上面两种声明无法起作用，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:contex</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>经过查阅博客，发现需要增添修改几个地方，改成如下url：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:contex</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans 		   http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>改完成之后，就成功了。运行程序，登录<a href="http://localhost:8080/TestSpringMVC_war_exploded/hello.do，即可跳转进http://localhost:8080/TestSpringMVC_war_exploded/jsp/success.jsp页面。" target="_blank" rel="noopener">http://localhost:8080/TestSpringMVC_war_exploded/hello.do，即可跳转进http://localhost:8080/TestSpringMVC_war_exploded/jsp/success.jsp页面。</a></p>
<p>解决完上述问题，把springmvc2.xml文件放入到resource文件夹里也能正确识别出来，只要加入如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc2.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  <span class="comment">&lt;!-- 从resource里找 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-AOP</title>
    <url>/2020/08/03/Spring-AOP/</url>
    <content><![CDATA[<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring-AOP"></a>Spring-AOP</h1><p>Spring中的AOP的全称是Aspect Oriented Programming，即：面向切面编程。当想给一个服务类的某个方法执行之前或者执行之后添加一些日志打印或者身份校验时，由于不能去改动源码，所以我们必须采用AOP的方式，得到一个与原类相似的代理类，通过改动此代理类来完成操作。</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>顾名思义，代理就是一个原本事务的替代品，帮助完成某个任务。类似于房产中介，他代替房东去卖房子，同时给顾客提供了查看其他房源的功能，这是房东所不能提供的，这便是功能的增强。而顾客不用去找到房东，也能满足自己想要租房的需求，这也是对房东的一种保护。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>在设计模式中有一种叫代理模式的设计模式，将原对象封装到一个代理对象中，通过代理对象访问原对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能（比如方法的前置或后置操作）。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>这种代理方式<strong>需要代理对象和目标对象实现一样的接口</strong>。在编译前完成对代理类的编写，将原对象封装至代理对象中，对原方法进行增强。简单点来说，就是创建一个组合类，把目标类当成代理类的类成员变量，在代理类的方法中调用目标类的方法。</p>
<p><strong>优点</strong>：</p>
<p>​        可以在不修改目标对象的前提下扩展目标对象的功能。</p>
<p><strong>缺点</strong>：</p>
<p>​        <strong>冗余</strong>。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。</p>
<p>​        <strong>不易维护</strong>。一旦接口增加方法，目标对象与代理对象都要进行修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserDao.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserDaoImpl.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"插入新的用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserDaoProxy.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(UserDao target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法增强</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开启新的事务"</span>);</span><br><span class="line">        target.insert();</span><br><span class="line">        System.out.println(<span class="string">"提交事务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 开启新的事务</span></span><br><span class="line"><span class="comment">* 插入新的用户</span></span><br><span class="line"><span class="comment">* 提交事务</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理分为<strong>JDK动态代理</strong>以及<strong>CGLIB动态代理</strong>，动态代理是在<strong>内存中创建</strong>代理对象来实现对原对象的代理。</p>
<h3 id="动态代理与静态代理的区别"><a href="#动态代理与静态代理的区别" class="headerlink" title="动态代理与静态代理的区别"></a>动态代理与静态代理的区别</h3><ul>
<li>动态代理是在运行时动态生成的，所以在项目中是没有.java和.class文件，它们是在运行中生成字节码，由JVM执行的；静态代理是项目编译前已经编写好的Java类，所以编译后在项目中是由.java和.class文件的</li>
<li>动态代理的代理对象不需要实现接口（注意是代理对象），而静态代理需要实现。</li>
</ul>
<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>JDK动态代理的目标对象是<strong>需要实现原对象的接口</strong>的（这里说的是原对象，即代理对象通过getProxyInstance方法返回的对象，而前面说的是代理对象不需要实现接口，这里说的不矛盾），如果目标对象不实现接口，则无法进行JDK动态代理。</p>
<p>主要方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java.lang.reflect.Proxy           #newProxyInstance</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,  //指定当前目标对象使用类加载器</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt;[] interfaces,    //目标对象实现的接口的类型</span></span></span><br><span class="line"><span class="function"><span class="params">    InvocationHandler h      //事件处理器</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//java.lang.reflect.InvocationHandler        #invoke</span></span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 在代理实例上处理方法调用并返回结果。</span></span></span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserDao.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserDaoImpl.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"保存数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserProxyFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxyFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;<span class="comment">// 维护一个目标对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为目标对象生成代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), 		                 target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                     <span class="comment">//InvocationHandler内部类实现</span></span><br><span class="line">                     <span class="comment">//InvocationHandler类的方法invoke编写</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="comment">//方法增强了</span></span><br><span class="line">                        System.out.println(<span class="string">"开启事务"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 执行目标对象方法</span></span><br><span class="line">                        Object returnValue = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"提交事务"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);  <span class="comment">//可以转换成lambda写法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserDao target = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">        UserDao proxy = (UserDao) <span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">        proxy.save();<span class="comment">//代理类执行目标类的方法，相当于执行InvocationHandler类的方法invoke</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*开启事务</span></span><br><span class="line"><span class="comment">*保存数据</span></span><br><span class="line"><span class="comment">*提交事务</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h2><p>cglib(Code Generation Library) CGLIB是一款优秀的Java字节码生成框架，它可以生成并操纵Java字节码。因此，CGLIB的动态代理其实就是使用字节码技术为目标类创建子类，并且在子类中拦截父类方法的调用，并且顺势织入横切逻辑。</p>
<p>CGLib代理与JDK代理的区别：使用JDK代理需要目标类实现接口，而<strong>CGLib无需实现接口</strong></p>
<p>使用cglib代理需要引入jar包（Spring中包含了CGLib），也可以通过<strong>maven引入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserDao.java 注意此时无需定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"保存数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ProxyFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;<span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为目标对象生成代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//工具类</span></span><br><span class="line">        Enhancer en = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置父类</span></span><br><span class="line">        en.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        en.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//创建子类对象代理</span></span><br><span class="line">        <span class="keyword">return</span> en.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//方法增强</span></span><br><span class="line">        System.out.println(<span class="string">"开启事务"</span>);</span><br><span class="line">        <span class="comment">// 执行目标对象的方法</span></span><br><span class="line">        Object returnValue = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"关闭事务"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserDao target = <span class="keyword">new</span> UserDao();</span><br><span class="line">        UserDao proxy = (UserDao) <span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*开启事务</span></span><br><span class="line"><span class="comment">*保存数据</span></span><br><span class="line"><span class="comment">*提交事务</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><strong>参考博客</strong>:  Creams’ Blog ——Java的代理模式</p>
<p><a href="http://codingcms.cn/2019/05/28/Proxy/" target="_blank" rel="noopener">http://codingcms.cn/2019/05/28/Proxy/</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring注解</title>
    <url>/2020/08/01/Spring-%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Spring-注解"><a href="#Spring-注解" class="headerlink" title="Spring-注解"></a>Spring-注解</h1><p>注解是Spring容器对于Bean的创建和对象属性的<strong>依赖注入</strong>的一种形式，注意使用注解的时候，要在配置xml中开启SpringIOC注解扫描，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启SpringIOC注解扫描 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.yiidian.dao"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="一、对于Bean的创建，Spring容器提供了以下四个注解的支持"><a href="#一、对于Bean的创建，Spring容器提供了以下四个注解的支持" class="headerlink" title="一、对于Bean的创建，Spring容器提供了以下四个注解的支持"></a>一、对于Bean的创建，Spring容器提供了以下四个注解的支持</h2><ol>
<li><p><strong>@Component</strong>          普通对象的创建</p>
</li>
<li><p><strong>@Repository</strong>            dao层实现类的注解</p>
</li>
<li><p><strong>@Service</strong>                   service层实现类的注解</p>
</li>
<li><p><strong>@Controller</strong>             controller层实现类的注解</p>
</li>
</ol>
<p>   以上四个注解在普通使用中是等效的，这个意思就是对于不同层的类，使用以上不同的注解，但是<strong>它们的功能是一样的，即为这个类，在xml的bean容器里创建一个对象。</strong></p>
<p>   同时，在使用以上四个注解时，可以在后面直接<strong>配置value值</strong>，此值对应着bean对象的唯一标识符id的值，即此<strong>对象的名字</strong>，如下所示：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value=<span class="string">"customerDao"</span>)  <span class="comment">//如果不加value，名称默认为类名：customerDaoImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerDaoImpl</span> <span class="keyword">implements</span> <span class="title">CustomerDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"测试SpringIOC的注解用法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、-Value注解"><a href="#二、-Value注解" class="headerlink" title="二、@Value注解"></a>二、@Value注解</h2><p>@Value注解的作用：注入普通数据类型，即给某个类中的普通类型成员变量注入值</p>
<p>使用此注解需要在src目录建立一个properties属性文件，然后在此文件中，分别写出每个成员变量所要取的值，然后在类中用@Value插入注解，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在src目录建立jdbc.properties</span></span><br><span class="line">jdbcUrl = jdbc:mysql:<span class="comment">///spring</span></span><br><span class="line">driverClass = com.mysql.jdbc.Driver</span><br><span class="line">user = root</span><br><span class="line">password = root</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value=<span class="string">"customerDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerDaoImpl</span> <span class="keyword">implements</span> <span class="title">CustomerDao</span> </span>&#123;</span><br><span class="line">	<span class="comment">//2Value注入普通数据</span></span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;jdbcUrl&#125;"</span>)     <span class="comment">//括号里是SpringEL语法</span></span><br><span class="line">	<span class="keyword">private</span> String jdbcUrl;</span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;driverClass&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String driverClass;</span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;user&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String user;</span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;password&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"CustomerDaoImpl [jdbcUrl="</span> + jdbcUrl + <span class="string">", driverClass="</span></span><br><span class="line">				+ driverClass + <span class="string">", user="</span> + user + <span class="string">", password="</span> + password</span><br><span class="line">				+ <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、-Autowired"><a href="#三、-Autowired" class="headerlink" title="三、@Autowired"></a>三、@Autowired</h2><p>@Autowired注解，可以对类成员变量、方法及构造函数进行标注，完成<strong>自动装配</strong>的工作。即对一个类的类成员变量使用此注解，会自动从bean容器中找到一个同名类的bean对象，把它注入给此类成员变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span>(value=<span class="string">"customerDao"</span>)   <span class="comment">//新建一个CustomerDaoImpl类bean对象，命名为customerDao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerDaoImpl</span> <span class="keyword">implements</span> <span class="title">CustomerDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"执行了CustomerDaoImpl的save()方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(value=<span class="string">"customerService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerServiceImpl</span> <span class="keyword">implements</span> <span class="title">CustomerService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span>    <span class="comment">//自动装配上面的customerDao bean对象给此同类型的类成员变量</span></span><br><span class="line">	<span class="keyword">private</span> CustomerDao customerDao;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		customerDao.save();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：当bean容器中有多个同类型但不同名的bean对象时，使用@Autowired会产生错误，此时需要搭配@Qualifier注解使用。</p>
<h2 id="四、-Qualifier"><a href="#四、-Qualifier" class="headerlink" title="四、@Qualifier"></a>四、@Qualifier</h2><p>当创建了多个具有相同类型的bean对象，但只想用其中一个bean对象进行注入时，需要用到@Autowired和@Qualifier消除混乱。先使用@Autowired选择相同类的bean对象，再使用@Qualifier来选择其中一个，@Qualifier注解后面加的是要注入的bean对象的唯一标识符 id值，即bean对象的名字，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span>(value=<span class="string">"customerDao1"</span>)   <span class="comment">//第一个bean对象customerDao1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerDaoMySQLImpl</span> <span class="keyword">implements</span> <span class="title">CustomerDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"customerDao的MySQL实现"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span>(value=<span class="string">"customerDao2"</span>)    <span class="comment">//第二个bean对象customerDao2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerDaoOracleImpl</span> <span class="keyword">implements</span> <span class="title">CustomerDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"customerDao的Oracle实现"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(value=<span class="string">"customerService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerServiceImpl</span> <span class="keyword">implements</span> <span class="title">CustomerService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="meta">@Qualifier</span>(<span class="string">"customerDao1"</span>)  <span class="comment">//指定了customerDao1 bean对象</span></span><br><span class="line">	<span class="keyword">private</span> CustomerDao customerDao;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		customerDao.save();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="五、-Resource"><a href="#五、-Resource" class="headerlink" title="五、@Resource"></a>五、@Resource</h2><p>@Resource注解，<strong>默认按照名称进行装配</strong>，名称可以通过name属性进行指定。 如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找。如果注解写在setter方法上默认取属性名进行装配。 <strong>当找不到与名称匹配的bean时才按照类型进行装配</strong>。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span>(value=<span class="string">"customerDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerDaoImpl</span> <span class="keyword">implements</span> <span class="title">CustomerDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"执行了CustomerDaoImpl的save()方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(value=<span class="string">"customerService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerServiceImpl</span> <span class="keyword">implements</span> <span class="title">CustomerService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Resource</span>(name=<span class="string">"customerDao"</span>)    <span class="comment">//注入名为customerDao的bean对象</span></span><br><span class="line">	<span class="keyword">private</span> CustomerDao customerDao;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		customerDao.save();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>参考博客：一点教程——Spring</strong>  </p>
<p><a href="http://www.yiidian.com/spring/ioc-annotation-helloworld.html" target="_blank" rel="noopener">http://www.yiidian.com/spring/ioc-annotation-helloworld.html</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring注解-循环依赖</title>
    <url>/2020/07/31/Spring%E6%B3%A8%E8%A7%A3-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h1 id="Spring注解-循环依赖"><a href="#Spring注解-循环依赖" class="headerlink" title="Spring注解-循环依赖"></a>Spring注解-循环依赖</h1><p>Spring中的注解，是实现IOC的方式之一，使用@Autowired，可以给一个类(<strong>有@Component、@Repository、@Service、@Controller中的某个注解，此注解会给这个类在xml中创建同名的类对象</strong>)的一个类成员变量注入一个xml中的bean对象，若是此bean不存在，则会在集合中创建一个对象再注入。</p>
<p>下面举个例子，假设有三个接口，每个接口都有一个实现类，分别是类A、类B、类C。类A中有成员变量类B，类B中有成员变量类C，类C中有成员变量类C。此时分别给三个类中的依赖类成员变量使用@Autowired，正常会发生什么？</p>
<p>先是类A的对象被创建，创建完成后，再创建类A中成员变量类B，由于类B中包含成员变量类C，所以创建完类B的对象后会继续创建类C的对象，又由于类C中包含成员变量类A，所以类C对象创建完后又继续创建类A的对象，依次无限循环创建下去。。。</p>
<p>Spring给出的解决方法是，用一个三级缓存，每一个缓存都是一个HashMap(存放键值对的容器)，其中键存放类对象的id，值存放这个类对象。当要创建类A对象时，发现没有此对象，所以首先创建类A的一个对象，存在第三级缓存中。接着要创建类A对象的成员变量类B，发送没有此类B对象，便创建一个类B对象，存在第三级缓存中。接下来便要创建类B对象中的成员变量类C，发现没有此类C对象，便创建一个类C对象放入第三级缓存中。然后由于类C对象有成员变量类A，需要创建类A对象，但此时搜索发现第三级缓存中有类A对象，于是把第三级缓存中的类A对象移动到第二级缓存，此时认为类C对象的成员变量类A对象已经存在了，于是认为类C对象完全创建成功，然后把类C对象放入第一级缓存中。此时认为类B对象的成员变量类C对象已经存在，于是认为类B对象完成创建成功，把此类B对象放入第一级缓存中。此时又认为类A对象的成员变量类B对象已经存在，于是认为类A对象完成创建成功，然后把类A对象放入第一级缓存，此时循环依赖问题就得以解决。</p>
<p><strong>注意</strong>：==当使用注解方法注入依赖时，可以解决==，但是==使用构造函数注入时并不能解决==。<strong>原因</strong>：假设类A对象通过构造函数创建，则成员变量类B便是此构造函数的参数，在调用构造函数创建类A对象时，会首先去创建类B对象，只有类B对象创建完成，才会真正完成对类A对象的创建。但是创建类B对象的时候，会调用类B的构造函数，而类C则是此构造函数的参数，所以创建类B对象之前，会去创建类C对象，而创建类C对象，会调用类C的构造函数，而类A则是此构造函数的参数，在创建类C对象之前，会创建类A对象，但由于类C没创建出来，所以类B就没创建出来，也就导致类A也没创建出来，没有类A对象，类C也无法创建，就又陷入了一个无限死循环中。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 数据库连接</title>
    <url>/2020/07/29/Java-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h2 id="Java-MySQL连接"><a href="#Java-MySQL连接" class="headerlink" title="Java MySQL连接"></a>Java MySQL连接</h2><p>Java和MySQL连接，需要一个jar包。在IDEA中，可以在<strong>File-&gt;Project Structure-&gt;Modules-&gt;Dependencies-&gt; 右侧+ -&gt;JARs or directories…-&gt;选择sql JDBC驱动包。</strong> </p>
<p><img src="/2020/07/29/Java-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/1.jpg" alt></p>
<p>若是使用maven创建的工程，则直接通过pom.xml来添加包依赖，如下图所示：</p>
<p><img src="/2020/07/29/Java-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/2.jpg" alt></p>
<p>然后在底下的终端输入：<strong>mvn clean package</strong> 重新加载pom.xml</p>
<p><img src="/2020/07/29/Java-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/3.jpg" alt></p>
<p>要连接数据库，还要选择添加数据库文件，在IDEA右侧的Database中，点击+号，如下所示：</p>
<p><img src="/2020/07/29/Java-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/4.jpg" alt></p>
<p>点击左上角的加号，选择Data Source，再选择MySQL</p>
<p><img src="/2020/07/29/Java-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/5.jpg" alt></p>
<p>然后填写User(数据库账号)、Password(数据库密码)、Database(数据库名称)，然后点击Test Connection，连接成功则如下所示。若不成功，则会出现弹框，缺少驱动，此时再根据弹框信息上网查找解决方法。</p>
<p><img src="/2020/07/29/Java-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/6.jpg" alt></p>
<h3 id="Java-MySQL连接代码"><a href="#Java-MySQL连接代码" class="headerlink" title="Java MySQL连接代码"></a>Java MySQL连接代码</h3><p>导入包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br></pre></td></tr></table></figure>

<p>数据库连接过程：先创建一个驱动基类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此类作为数据库的驱动类，不需要创造实例，因此方法设置为static类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBConnect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数据库驱动</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.cj.jdbc.Driver"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://localhost:3306/testservlet"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库的用户名和密码</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String account = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String password = <span class="string">"a1210080212"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connection = <span class="keyword">null</span>;     <span class="comment">//数据连接对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Statement statement = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块加载驱动</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class.forName(JDBC_DRIVER);    <span class="comment">//必须要最先执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();     <span class="comment">//若是出现异常，打印信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建数据库连接对象connection</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(connection == <span class="keyword">null</span>)&#123;</span><br><span class="line">            connection = DriverManager.getConnection(DB_URL, account, password);</span><br><span class="line">            <span class="keyword">return</span> connection;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭连接对象，语句对象，结果对象资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection connection, Statement statement, ResultSet resultSet)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(connection != <span class="keyword">null</span>)</span><br><span class="line">                connection.close();</span><br><span class="line">            <span class="keyword">if</span>(statement != <span class="keyword">null</span>)</span><br><span class="line">                statement.close();</span><br><span class="line">            <span class="keyword">if</span>(resultSet != <span class="keyword">null</span>)</span><br><span class="line">                resultSet.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断SQL语句是否执行成功</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">executeSQL</span><span class="params">(String sql)</span></span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            connection = getConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Statement statement = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            statement = connection.createStatement();</span><br><span class="line">            <span class="keyword">return</span> statement.executeUpdate(sql) &gt; <span class="number">0</span>;  <span class="comment">//执行这条语句也可能引发SQLException异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            close(connection, statement, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;       <span class="comment">//sql语句没有执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后根据从数据库表单所要增删改查的不同的表单，来创建不同的类，并且编写不同的方法，但是都继承上面的驱动基类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DAO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Entity.User;</span><br><span class="line"><span class="keyword">import</span> Connect.DBConnect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDAO</span> <span class="keyword">extends</span> <span class="title">DBConnect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;User&gt; <span class="title">getAllUser</span><span class="params">()</span></span>&#123;        <span class="comment">//获得一个包含所有user的数组</span></span><br><span class="line">        ArrayList&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Connection connection = getConnection();    <span class="comment">//创建数据库连接对象</span></span><br><span class="line">            String sql = <span class="string">"select * from user"</span>;</span><br><span class="line"></span><br><span class="line">            PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">            ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);    <span class="comment">//sql语句转变成statement，创建preparedStatement对象</span></span><br><span class="line">            resultSet = preparedStatement.executeQuery();     <span class="comment">//执行sql语句，结果放到resultSet</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">                User user = <span class="keyword">new</span> User();</span><br><span class="line">                user.setId(resultSet.getString(<span class="string">"id"</span>));</span><br><span class="line">                user.setName(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">                user.setSex(resultSet.getString(<span class="string">"sex"</span>));</span><br><span class="line">                user.setAccount(resultSet.getString(<span class="string">"account"</span>));</span><br><span class="line">                user.setPassword(resultSet.getString(<span class="string">"password"</span>));</span><br><span class="line">                userList.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception f)&#123;</span><br><span class="line">            f.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span></span>&#123;    <span class="comment">//为数据库插入一个User</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Connection connection = getConnection();</span><br><span class="line">            PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">            String sql = <span class="string">"insert into user (id, name, sex, account, password) values (?, ?, ?, ?, ?)"</span>;</span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>, user.getId());</span><br><span class="line">            preparedStatement.setString(<span class="number">2</span>, user.getName());</span><br><span class="line">            preparedStatement.setString(<span class="number">3</span>, user.getSex());</span><br><span class="line">            preparedStatement.setString(<span class="number">4</span>, user.getAccount());</span><br><span class="line">            preparedStatement.setString(<span class="number">5</span>, user.getPassword());</span><br><span class="line">            <span class="keyword">int</span> i = preparedStatement.executeUpdate();    <span class="comment">//对于sql插入语句必须要使用executeUpdate()方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">truncateTable</span><span class="params">()</span></span>&#123;               <span class="comment">//删除整个表</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Connection connection = getConnection();</span><br><span class="line">            PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">            String sql = <span class="string">"truncate table user"</span>;</span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUserById</span><span class="params">(String id)</span></span>&#123;          <span class="comment">//通过id删除一条数据</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Connection connection = getConnection();</span><br><span class="line">            PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">            String sql = <span class="string">"delete from user where id = "</span> + id;</span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">int</span> i = preparedStatement.executeUpdate();       <span class="comment">//删除语句使用executeUpdate()方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>&#123;                <span class="comment">//更改一个User的数据</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Connection connection = getConnection();</span><br><span class="line">            PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">            String sql = <span class="string">"update user set id = ?, name = ?, sex = ?, account = ?, password = ? where id = ?"</span>;</span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>, user.getId());</span><br><span class="line">            preparedStatement.setString(<span class="number">2</span>, user.getName());</span><br><span class="line">            preparedStatement.setString(<span class="number">3</span>, user.getSex());</span><br><span class="line">            preparedStatement.setString(<span class="number">4</span>, user.getAccount());</span><br><span class="line">            preparedStatement.setString(<span class="number">5</span>, user.getPassword());</span><br><span class="line">            preparedStatement.setString(<span class="number">6</span>, user.getId());</span><br><span class="line">            <span class="keyword">int</span> i = preparedStatement.executeUpdate();     <span class="comment">//update sql语句要用executeUpdate()方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(String id)</span></span>&#123;   <span class="comment">//通过ID查询User对象</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Connection connection = getConnection();</span><br><span class="line">            PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">            ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            String sql = <span class="string">"select * from user where id = ?"</span>;</span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>, id);</span><br><span class="line">            resultSet = preparedStatement.executeQuery();     <span class="comment">//select sql语句使用executeQuery()方法</span></span><br><span class="line"></span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">                user.setId(resultSet.getString(<span class="string">"id"</span>));</span><br><span class="line">                user.setName(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">                user.setSex(resultSet.getString(<span class="string">"sex"</span>));</span><br><span class="line">                user.setAccount(resultSet.getString(<span class="string">"account"</span>));</span><br><span class="line">                user.setPassword(resultSet.getString(<span class="string">"password"</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//System.out.println(user.getId() + ' ' + user.getName() + ' ' + user.getSex() + ' ' + user.getAccount() + ' ' + user.getPassword());</span></span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般方法步骤是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection connection = getConnection();        <span class="comment">//获得连接对象</span></span><br><span class="line">PreparedStatement preparedStatement = <span class="keyword">null</span>;     </span><br><span class="line">ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">"select * from user where id = ?"</span>;   <span class="comment">//sql语句，？是不确定的值</span></span><br><span class="line">preparedStatement = connection.prepareStatement(sql);  <span class="comment">//获得preparedStatement对象</span></span><br><span class="line">preparedStatement.setString(<span class="number">1</span>, id);   <span class="comment">//给sql语句的?号设置值为id</span></span><br><span class="line">resultSet = preparedStatement.executeQuery();     <span class="comment">//获得resultSet结果对象，即执行完sql语句的结果放到resultSet里</span></span><br><span class="line"><span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">    <span class="comment">//通过while来遍历resultSet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet总结</title>
    <url>/2020/07/21/Servlet%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>Servlet采用Java语言编写，是运行在Web服务器上的<strong>程序</strong>，它是作为浏览器客户端和服务器上的数据库或应用程序之间的<strong>中间层</strong>。(即一个编写的类)</p>
<p>使用Servlet，可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态地创建网页。</p>
<p>下图显示了Servlet在Web应用程序中的位置。</p>
<p><img src="/2020/07/21/Servlet%E6%80%BB%E7%BB%93/1.jpg" alt></p>
<h3 id="Servlet包"><a href="#Servlet包" class="headerlink" title="Servlet包"></a>Servlet包</h3><p>Servlet可以使用<strong>javax.servlet</strong>和<strong>javax.servlet.http</strong>包创建</p>
<h3 id="设置Web服务器：Tomcat"><a href="#设置Web服务器：Tomcat" class="headerlink" title="设置Web服务器：Tomcat"></a>设置Web服务器：Tomcat</h3><p>Tomcat是一款独立服务器，可以用来测试Servlet。由于Servlet是作为客户端和服务器的中间程序，所以我们测试Servlet程序的时候，需要用到浏览器和客户端。我们电脑自身就属于浏览器客户端，与此同时我们打开这个Tomcat，此时我们的电脑成了一个独立服务器。这样此电脑即是客户端，又是服务器，方便调试Servlet程序。</p>
<h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><p>Servlet生命周期可被定义为从创建直到毁灭的整个过程：<br>1、Servlet通过调用init()方法进行初始化。<br>2、Servlet调用service()方法来处理客户端的请求。<br>3、Servlet通过调用destroy()方法终止。<br>4、最后Servlet是由JVM的垃圾回收器进行垃圾回收的。</p>
<h4 id="init-方法"><a href="#init-方法" class="headerlink" title="init()方法"></a>init()方法</h4><p>init()方法在第一次创建Servlet时被调用，在后续每次用户请求时不再调用。Servlet创建于用户第一次调用对应于该Servlet的URL时候，也可以指定Servlet在服务器第一次启动时被加载。<strong>当用户调用一个Servlet时，就会创建一个Servlet实例，每一个用户请求都会产生一个新的线程。</strong><br><strong>init()方法即servlet类的构造器</strong>，它简单地创建或加载一些数据，这些数据将被用于Servlet的整个生命周期。定义方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="service方法"><a href="#service方法" class="headerlink" title="service方法"></a>service方法</h4><p>service()方法是执行实际任务的主要方法，用来处理来自客户端(浏览器)的请求，并把格式化的响应写回给客户端。<br>每次服务器接收到一个Servlet请求时，服务器会产生一个新的线程并调用服务。Service()方法检查HTTP的请求类型(GET,POST,PUT,DELETE等)，并在适当的时候调用doGet、doPost、doPut、doDelete等方法。<br><strong>浏览器点击一个链接或者提交一个信息，就相当于给服务器提交了一个请求，根据不同的请求，Servlet会做出一系列不同的处理，然后使得服务器给出响应，这样浏览器就能成功的进行到下个页面或者下个进程。</strong>定义方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//前一个参数是请求引用，后一个是响应引用</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doGet()和doPost()方法是每次服务请求中最常用的方法。</p>
<h5 id="doGet-方法"><a href="#doGet-方法" class="headerlink" title="doGet()方法"></a>doGet()方法</h5><p>GET请求来自于一个URL的正常请求，或者来自于一个<strong>未指定method的HTML表单</strong>(即HTML页面中要提交的表格信息)，它由doGet()方法处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Servlet代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="doGet-方法-1"><a href="#doGet-方法-1" class="headerlink" title="doGet()方法"></a>doGet()方法</h5><p>POST请求来自于一个特别指定了METHOD为POST的HTML表单，它由doPost()方法处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Servlet代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="destroy-方法"><a href="#destroy-方法" class="headerlink" title="destroy()方法"></a>destroy()方法</h4><p>destroy()方法只会被掉用一次，在Servlet生命周期结束时被调用。destroy()方法<strong>可以让Servlet关闭数据库连接、停止后台线程、把Cookie列表或点击计数器写入到磁盘，并 执行其他类似的清理活动。</strong>在调用destroy()方法之后，Servlet对象被标记为垃圾回收，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//终止化代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p>下图显示了一个典型的Servlet生命周期方案：<br><strong>·第一个到达服务器的HTTP请求被委派到Servlet容器。</strong><br><strong>·Servlet容器在调用service()方法之前加载Servlet。</strong><br><strong>·然后Servlet容器处理由多个线程产生的多个请求，每个线程执行一个单一的Servlet实例的service()方法。</strong></p>
<p><img src="/2020/07/21/Servlet%E6%80%BB%E7%BB%93/2.jpg" alt></p>
<h3 id="Servlet实例"><a href="#Servlet实例" class="headerlink" title="Servlet实例"></a>Servlet实例</h3><p>Servlet是服务HTTP请求并实现javax.servlet.Servlet接口的Java类。Web应用程序开发人员通常编写Servlet类来扩展javax.servlet.http.HttpServlet，并实现Servlet接口的抽象类专门用来处理HTTP请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入必需的 java 库</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展 HttpServlet 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">// 执行必需的初始化</span></span><br><span class="line">      message = <span class="string">"Hello World"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">// 设置响应内容类型</span></span><br><span class="line">      response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 实际的逻辑是在这里</span></span><br><span class="line">      PrintWriter out = response.getWriter();</span><br><span class="line">      out.println(<span class="string">"&lt;h1&gt;"</span> + message + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理 POST 方法请求的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">// 什么也不做</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Servlet部署"><a href="#Servlet部署" class="headerlink" title="Servlet部署"></a>Servlet部署</h3><p>在一个项目工程中，编写完Servlet的类之后，<strong>还需要编写web.xml文件中的内容</strong>，在<web-app>…</web-app>标签中间填写以下条目(由上知这个编写的类是HelloWorld)。<br><strong>(定义一个servlet，就映射到一个URL)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;web-app&gt;      </span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">HelloWorld</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    &lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">HelloWorld</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">HelloWorld</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt; //此条目很重要，其中的/必不可少，中间内容是指服务器返回的响应的域名名称</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">web</span>-<span class="title">app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Servlet表单数据"><a href="#Servlet表单数据" class="headerlink" title="Servlet表单数据"></a>Servlet表单数据</h3><p>很多情况下，需要传递一些信息，<strong>从浏览器到WEB服务器</strong>。浏览器使用两种方法可将这些信息传递到WEB服务器，分别为GET方法和POST方法。</p>
<h4 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h4><p>GET方法向页面请求发送已编码的用户信息，<strong>页面和已编码的信息中间用?字符分隔，即信息出现在浏览器页面的地址中</strong>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//www.test.com/hello?key1=value1&amp;key2=value2</span></span><br></pre></td></tr></table></figure>
<p>GET方法是默认的从浏览器向Web服务器传递信息的方法，它会产生一个很长到的字符串，出现在浏览器的地址栏中。<strong>如果要向服务器传递的是密码或其他的敏感信息，不要使用GET方法。</strong>GET方法有大小限制，请求字符串中最多只能有1024个字符。Servlet采用doGet()方法处理这些请求。</p>
<h4 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h4><p>POST方法打包信息的方法与GET方法基本相同，但是POST方法不是把信息作为浏览器页面地址URL中的?字符后面的文本字符串进行发送，而是<strong>把这些信息作为一个单独的消息，以标准输出的形式传到后台程序，可以解析和使用这些标准输出。</strong>Servlet使用doPost()方法处理这些类型的请求。</p>
<h4 id="使用Servlet读取表单数据"><a href="#使用Servlet读取表单数据" class="headerlink" title="使用Servlet读取表单数据"></a>使用Servlet读取表单数据</h4><p>Servlet处理表单数据，这些数据会根据不同的情况使用不同的方法自动解析：<br><strong>·getParameter()</strong>: 调用request.getParameter()方法来获取表单参数的值。<br><strong>·getParameterValues()</strong>: 如果参数出现一次以上，则调用该方法，并返回多个值，例如复选框<br><strong>·getParameterNames()</strong>: 如果想要得到当前请求中的所有参数的完整列表，则调用该方法<br><strong>(方法都是在request对象上调用的)</strong></p>
<h5 id="读取名称-如果表单提交的数据中有中文数据则需要转码"><a href="#读取名称-如果表单提交的数据中有中文数据则需要转码" class="headerlink" title="读取名称(如果表单提交的数据中有中文数据则需要转码)"></a>读取名称(如果表单提交的数据中有中文数据则需要转码)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = <span class="keyword">new</span> String(requset.getParameter(<span class="string">"name"</span>).getBytes(<span class="string">"ISO-8859-1"</span>), <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>

<h5 id="读取URL"><a href="#读取URL" class="headerlink" title="读取URL"></a>读取URL</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getParameter(<span class="string">"url"</span>);</span><br></pre></td></tr></table></figure>

<p>一般处理POST请求的方法，是直接使用GET请求的方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取所用参数时，采用<strong>getParameterNames()</strong>方法，返回的是Enumeration类型的枚举，其中包含未指定顺序的参数名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enumeration paramNames = request.getParameterNames();</span><br></pre></td></tr></table></figure>
<p>遍历其中参数，使用<strong>hasMoreElements()</strong>方法判断是否还有参数，使用<strong>nextElement()</strong>方法取下一个参数名，再通过此参数名，使用<strong>getParameterValues()</strong>方法来获取此参数名所对应的值，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取数据并用html画出表格</span></span><br><span class="line"><span class="keyword">while</span>(paramNames.hasMoreElements()) &#123;</span><br><span class="line">        String paramName = (String)paramNames.nextElement();</span><br><span class="line">        out.print(<span class="string">"&lt;tr&gt;&lt;td&gt;"</span> + paramName + <span class="string">"&lt;/td&gt;\n"</span>);</span><br><span class="line">        String[] paramValues = request.getParameterValues(paramName);</span><br><span class="line">        <span class="comment">// 读取单个值的数据</span></span><br><span class="line">        <span class="keyword">if</span> (paramValues.length == <span class="number">1</span>) &#123;</span><br><span class="line">            String paramValue = paramValues[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (paramValue.length() == <span class="number">0</span>)</span><br><span class="line">                out.println(<span class="string">"&lt;td&gt;&lt;i&gt;没有值&lt;/i&gt;&lt;/td&gt;"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                out.println(<span class="string">"&lt;td&gt;"</span> + paramValue + <span class="string">"&lt;/td&gt;"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 读取多个值的数据</span></span><br><span class="line">            out.println(<span class="string">"&lt;td&gt;&lt;ul&gt;"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; paramValues.length; i++) &#123;</span><br><span class="line">                out.println(<span class="string">"&lt;li&gt;"</span> + paramValues[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(<span class="string">"&lt;/ul&gt;&lt;/td&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            out.print(<span class="string">"&lt;/tr&gt;"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Servlet客户端HTTP请求"><a href="#Servlet客户端HTTP请求" class="headerlink" title="Servlet客户端HTTP请求"></a>Servlet客户端HTTP请求</h3><p>当浏览器请求网页时，它会向 Web 服务器发送特定信息，这些信息不能被直接读取，因为这些信息是作为 HTTP 请求的头的一部分进行传输的。可以查看<a href="https://www.runoob.com/http/http-tutorial.html" target="_blank" rel="noopener">HTTP协议</a>了解更多信息。</p>
<p>使用HttpServletRequest的<strong>getHeaderNames()</strong>方法(对request对象调用)来读取HTTP头信息，该方法同样返回一个枚举，包含与当前的HTTP请求相关的头信息。一旦我们得到了这个枚举，就可以用上述的方式循环枚举，使用hasMoreElements()方法来确定何时停止，使用nextElement()方法来获取每个参数的名称。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enumeration headerNames = request.getHeaderNames();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(headerNames.hasMoreElements()) &#123;</span><br><span class="line">        String paramName = (String)headerNames.nextElement();</span><br><span class="line">        out.print(<span class="string">"&lt;tr&gt;&lt;td&gt;"</span> + paramName + <span class="string">"&lt;/td&gt;\n"</span>);</span><br><span class="line">        String paramValue = request.getHeader(paramName);</span><br><span class="line">        out.println(<span class="string">"&lt;td&gt; "</span> + paramValue + <span class="string">"&lt;/td&gt;&lt;/tr&gt;\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    out.println(<span class="string">"&lt;/table&gt;\n&lt;/body&gt;&lt;/html&gt;"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Servlet服务器HTTP响应"><a href="#Servlet服务器HTTP响应" class="headerlink" title="Servlet服务器HTTP响应"></a>Servlet服务器HTTP响应</h3><p>当浏览器向服务器发出请求时，服务器会返回给浏览器响应。当一个Web服务器响应一个HTTP请求时，响应通常包括一个状态行、一些响应报头、一个空行和文档。一个典型的响应如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK </span><br><span class="line">Content-Type: text&#x2F;html    &#x2F;&#x2F;状态行</span><br><span class="line">Header2: ...               &#x2F;&#x2F;响应报头</span><br><span class="line">...</span><br><span class="line">HeaderN: ...</span><br><span class="line">  (Blank Line)             &#x2F;&#x2F;空行</span><br><span class="line">&lt;!doctype ...&gt;             &#x2F;&#x2F;消息主体</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;...&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">...</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>状态行包括HTTP版本(本例中为HTTP/1.1)、一个状态码(在本例中为200)和一个对应于状态码的对消息(在本例中为OK)。HTTP1.1响应报头种类和描述以及设置HTTP响应报头的方法在如下链接：<br><strong>菜鸟教程：Servlet服务器HTTP响应</strong> : <a href="https://www.runoob.com/servlet/servlet-server-response.html" target="_blank" rel="noopener">https://www.runoob.com/servlet/servlet-server-response.html</a></p>
<h5 id="设置响应内容类型"><a href="#设置响应内容类型" class="headerlink" title="设置响应内容类型"></a>设置响应内容类型</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br></pre></td></tr></table></figure>

<h5 id="设置刷新自动加载时间为5秒"><a href="#设置刷新自动加载时间为5秒" class="headerlink" title="设置刷新自动加载时间为5秒"></a>设置刷新自动加载时间为5秒</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setIntHeader(<span class="string">"Refresh"</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Servlet-HTTP状态码"><a href="#Servlet-HTTP状态码" class="headerlink" title="Servlet HTTP状态码"></a>Servlet HTTP状态码</h3><p>可能从Web服务器返回的HTTP状态码和相关的信息列表在如下链接：<br><strong>菜鸟教程：Servlet Http状态码</strong> : <a href="https://www.runoob.com/servlet/servlet-http-status-codes.html" target="_blank" rel="noopener">https://www.runoob.com/servlet/servlet-http-status-codes.html</a></p>
<h4 id="设置HTTP状态代码的方法"><a href="#设置HTTP状态代码的方法" class="headerlink" title="设置HTTP状态代码的方法"></a>设置HTTP状态代码的方法</h4><p><strong>·public void setStatus(int statusCode)</strong>: 该方法设置一个任意的状态码。setStatus方法接受一个int(状态码)作为参数。如果响应包含了一个特殊的状态码和文档，确保在使用PrintWriter实际返回任何内容之前调用setStatus。<br><strong>·public void sendRedirect(String url)</strong>: 该方法生成一个302响应，连同一个带有新文档URL的Location头。<br><strong>·public void sendError(int code, String message)</strong>: 该方法发送一个状态码(通常404)，连同一个在HTML文档内部自动格式化并发送到客户端的短消息。</p>
<p>把407错误代码发送到客户端浏览器，浏览器会显示”Need authentication!!!”消息。在doGet方法中处理，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理 GET 方法请求的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">// 设置错误代码和原因</span></span><br><span class="line">      response.sendError(<span class="number">407</span>, <span class="string">"Need authentication!!!"</span> );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Servlet编写过滤器"><a href="#Servlet编写过滤器" class="headerlink" title="Servlet编写过滤器"></a>Servlet编写过滤器</h3><p>Servlet过滤器可以<strong>动态地拦截请求和响应</strong>，以变换或使用包含在请求或响应中的信息。可以将一个或多个Servlet过滤器附加到一个Servlet或一组Servlet。Servlet过滤器也可以附加到JSP文件和HTML页面，在调用Servlet前调用所有附加的Servlet过滤器。</p>
<p>Servlet过滤器是可用于Servlet编程的Java类，可以实现以下目的：<br><strong>·在客户端的请求访问后端资源之前，拦截这些请求。</strong><br><strong>·在服务器的响应发送回客户端之前，处理这些响应。</strong></p>
<p>根据规范建议的各种类型的过滤器：<br><strong>·身份验证过滤器</strong><br><strong>·数据压缩过滤器</strong><br><strong>·加密过滤器</strong><br><strong>·触发资源访问事件过滤器</strong><br><strong>·图像转换过滤器</strong><br><strong>·日志记录和审核过滤器</strong><br><strong>·MIME-TYPE链过滤器</strong><br><strong>·标记化过滤器</strong><br><strong>·XSL/T过滤器</strong></p>
<p>过滤器通过<strong>web.xml标签</strong>来声明，然后映射到应用程序部署描述符中的Servlet名称或URL模式。当Web容器启动Web应用程序时，它会为部署描述符中声明的每一个过滤器创建一个实例。Filter的执行顺序与在Web.xml配置文件中的配置顺序一致，一般把Filter配置在所有的Servlet之前。</p>
<h4 id="Servlet过滤器方法"><a href="#Servlet过滤器方法" class="headerlink" title="Servlet过滤器方法"></a>Servlet过滤器方法</h4><p>过滤器是一个实现了<strong>javax.servlet.Filter接口</strong>的Java类，javax.servlet.Filter接口定义了三个方法：<br><strong>·public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</strong>：该方法完成实际的过滤操作，当客户端请求方法与过滤器设置匹配的URL时，Servlet容器将先调用过滤器的doFilter()方法，FilterChain用户访问后续过滤器。<br><strong>·public void init(FilterConfig filterConfig)</strong>：web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。<br><strong>·public void destroy()</strong>：Servlet容器在销毁过滤器实例前调用该方法，在该方法中释放Servlet过滤器占用的资源。</p>
<h4 id="FilterConfig使用"><a href="#FilterConfig使用" class="headerlink" title="FilterConfig使用"></a>FilterConfig使用</h4><p>Filter的init方法中提供了一个FilterConfig对象，web.xml文件配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">LogFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">Site</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">value</span>&gt;菜鸟教程&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在init方法使用FilterConfig对象获取参数，使用<strong>config.getInitParameter()</strong>方法来获取参数，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取初始化参数</span></span><br><span class="line">    String site = config.getInitParameter(<span class="string">"Site"</span>); </span><br><span class="line">    <span class="comment">// 输出初始化参数</span></span><br><span class="line">    System.out.println(<span class="string">"网站名称: "</span> + site); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Servlet过滤器实例"><a href="#Servlet过滤器实例" class="headerlink" title="Servlet过滤器实例"></a>Servlet过滤器实例</h4><p>Servlet是一个编写的实现了Filter接口的Java类，以下是Servlet过滤器的实例，将输出网站名称和地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入必需的 java 库</span></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现 Filter 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取初始化参数</span></span><br><span class="line">        String site = config.getInitParameter(<span class="string">"Site"</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出初始化参数</span></span><br><span class="line">        System.out.println(<span class="string">"网站名称: "</span> + site); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> java.io.IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出站点名称</span></span><br><span class="line">        System.out.println(<span class="string">"站点网址：http://www.runoob.com"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把请求传回过滤链</span></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">( )</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 在 Filter 实例被 Web 容器从服务移除之前调用 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Web-xml中的Servlet过滤器映射"><a href="#Web-xml中的Servlet过滤器映射" class="headerlink" title="Web.xml中的Servlet过滤器映射"></a>Web.xml中的Servlet过滤器映射</h4><p>定义过滤器，然后映射到一个URL或Servlet，这与定义Servlet，然后映射到一个URL模式方向大致相同。在web.xml中为filter标签创建下面的条目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;web-app&gt;  </span><br><span class="line">&lt;filter&gt;</span><br><span class="line">  &lt;filter-name&gt;LogFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">  &lt;filter-class&gt;LogFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">  &lt;init-param&gt;                      &#x2F;&#x2F;多了初始化参数</span><br><span class="line">    &lt;param-name&gt;Site&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;菜鸟教程&lt;&#x2F;param-value&gt;</span><br><span class="line">  &lt;&#x2F;init-param&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;        </span><br><span class="line">  &lt;filter-name&gt;LogFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br><span class="line">&lt;servlet&gt;  </span><br><span class="line">  &lt;!-- 类名 --&gt;  </span><br><span class="line">  &lt;servlet-name&gt;DisplayHeader&lt;&#x2F;servlet-name&gt;  </span><br><span class="line">  &lt;!-- 所在的包 --&gt;  </span><br><span class="line">  &lt;servlet-class&gt;com.runoob.test.DisplayHeader&lt;&#x2F;servlet-class&gt;  </span><br><span class="line">&lt;&#x2F;servlet&gt;  </span><br><span class="line">&lt;servlet-mapping&gt;  </span><br><span class="line">  &lt;servlet-name&gt;DisplayHeader&lt;&#x2F;servlet-name&gt;  </span><br><span class="line">  &lt;!-- 访问的网址 --&gt;  </span><br><span class="line">  &lt;url-pattern&gt;&#x2F;TomcatTest&#x2F;DisplayHeader&lt;&#x2F;url-pattern&gt;  </span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;  </span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure>
<p><strong>上述过滤器适用于所有的Servlet，因为在配置中指定了/*，如果只是想在少数的Servlet上应用过滤器，可以指定一个特定的Servlet路径。</strong></p>
<h4 id="使用多个过滤器"><a href="#使用多个过滤器" class="headerlink" title="使用多个过滤器"></a>使用多个过滤器</h4><p>Web应用程序可以根据特定的目的定义若干个不同的过滤器，假设定义了两个过滤器AuthenFilter和LogFilter，需要创建一个如下所述的不同的映射：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">   &lt;filter-name&gt;LogFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">   &lt;filter-class&gt;com.runoob.test.LogFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">   &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;test-param&lt;&#x2F;param-name&gt;</span><br><span class="line">      &lt;param-value&gt;Initialization Paramter&lt;&#x2F;param-value&gt;</span><br><span class="line">   &lt;&#x2F;init-param&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter&gt;</span><br><span class="line">   &lt;filter-name&gt;AuthenFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">   &lt;filter-class&gt;com.runoob.test.AuthenFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">   &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;test-param&lt;&#x2F;param-name&gt;</span><br><span class="line">      &lt;param-value&gt;Initialization Paramter&lt;&#x2F;param-value&gt;</span><br><span class="line">   &lt;&#x2F;init-param&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">   &lt;filter-name&gt;LogFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">   &lt;filter-name&gt;AuthenFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure>
<p>先定义过滤器，再进行过滤器对URL的映射</p>
<h4 id="过滤器的应用顺序"><a href="#过滤器的应用顺序" class="headerlink" title="过滤器的应用顺序"></a>过滤器的应用顺序</h4><p><strong>web.xml中的filter-mapping元素的顺序</strong>决定了Web容器应用过滤器到Servlet的顺序，若要反转过滤器的的顺序，只需要在web.xml文件中反转filter-mapping元素即可。<br>若上述实例先应用LogFilter，然后再应用AuthenFilter，web.xml如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">   &lt;filter-name&gt;AuthenFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">   &lt;filter-name&gt;LogFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<h4 id="web-xml配置各节点说明"><a href="#web-xml配置各节点说明" class="headerlink" title="web.xml配置各节点说明"></a>web.xml配置各节点说明</h4><p>web.xml的配置各节点的说明在如下网址中所示：<br><strong>菜鸟教程：Servlet编写过滤器</strong> : <a href="https://www.runoob.com/servlet/servlet-writing-filters.html" target="_blank" rel="noopener">https://www.runoob.com/servlet/servlet-writing-filters.html</a></p>
<p>###Servlet异常处理<br>当一个Servlet抛出一个异常时，Web容器在使用了exception-type元素的web.xml中搜索与抛出异常类型相匹配的配置。必须在web.xml中使用<strong>error-page</strong>元素来指定对<strong>特定异常或HTTP状态码</strong>作出相应的Servlet调用。</p>
<h4 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a>web.xml配置</h4><p>假设，有一个ErrorHandler的Servlet在任何已定义的异常或错误出现时被调用，以下是在web.xml中创建的项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- servlet 定义 --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;ErrorHandler&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;ErrorHandler&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line">&lt;!-- servlet 映射 --&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;ErrorHandler&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;&#x2F;ErrorHandler&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- error-code 相关的错误页面 --&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;error-code&gt;404&lt;&#x2F;error-code&gt;</span><br><span class="line">    &lt;location&gt;&#x2F;ErrorHandler&lt;&#x2F;location&gt;</span><br><span class="line">&lt;&#x2F;error-page&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;error-code&gt;403&lt;&#x2F;error-code&gt;</span><br><span class="line">    &lt;location&gt;&#x2F;ErrorHandler&lt;&#x2F;location&gt;</span><br><span class="line">&lt;&#x2F;error-page&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- exception-type 相关的错误页面 --&gt;</span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;exception-type&gt;javax.servlet.ServletException&lt;&#x2F;exception-type &gt;</span><br><span class="line">    &lt;location&gt;&#x2F;ErrorHandler&lt;&#x2F;location&gt;</span><br><span class="line">&lt;&#x2F;error-page&gt;</span><br><span class="line"></span><br><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;exception-type&gt;java.io.IOException&lt;&#x2F;exception-type &gt;</span><br><span class="line">    &lt;location&gt;&#x2F;ErrorHandler&lt;&#x2F;location&gt;</span><br><span class="line">&lt;&#x2F;error-page&gt;</span><br></pre></td></tr></table></figure>
<p><strong>如果想对所有的异常有一个通用的错误处理程序，那么应该定义下面的error-page，而不是为每个异常定义单独的error-page元素：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;exception-type&gt;java.lang.Throwable&lt;&#x2F;exception-type &gt;</span><br><span class="line">    &lt;location&gt;&#x2F;ErrorHandler&lt;&#x2F;location&gt;</span><br><span class="line">&lt;&#x2F;error-page&gt;</span><br></pre></td></tr></table></figure>

<h4 id="请求属性-错误-异常"><a href="#请求属性-错误-异常" class="headerlink" title="请求属性-错误/异常"></a>请求属性-错误/异常</h4><p>以下是错误处理的Servlet可以访问的请求属性列表，用来分析错误/异常的性质。<br><strong>·javax.servlet.error.status_code</strong>：该属性给出状态码，状态码可被存储，并在存储为 java.lang.Integer 数据类型后可被分析。<br><strong>·javax.servlet.error.exception_type</strong>：该属性给出异常类型的信息，异常类型可被存储，并在存储为 java.lang.Class 数据类型后可被分析。<br><strong>·javax.servlet.error.message</strong>：该属性给出确切错误消息的信息，信息可被存储，并在存储为 java.lang.String 数据类型后可被分析。<br><strong>·javax.servlet.error.request_uri</strong>：该属性给出有关 URL 调用 Servlet 的信息，信息可被存储，并在存储为 java.lang.String 数据类型后可被分析。<br><strong>·javax.servlet.error.exception</strong>：该属性给出异常产生的信息，信息可被存储，并在存储为 java.lang.Throwable 数据类型后可被分析。<br><strong>·javax.servlet.error.servlet_name</strong>：该属性给出 Servlet 的名称，名称可被存储，并在存储为 java.lang.String 数据类型后可被分析。</p>
<p>从请求中得到错误或者异常，采用<strong>request.getAttribute()</strong>方法，来获得请求中产生的异常，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Throwable throwable = (Throwable)request.getAttribute(<span class="string">"javax.servlet.error.exception"</span>);</span><br><span class="line">Integer statusCode = (Integer)request.getAttribute(<span class="string">"javax.servlet.error.status_code"</span>);</span><br><span class="line">String servletName = (String)request.getAttribute(<span class="string">"javax.servlet.error.servlet_name"</span>);</span><br><span class="line">String requestUri = (String)request.getAttribute(<span class="string">"javax.servlet.error.request_uri"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Servlet-Cookie处理"><a href="#Servlet-Cookie处理" class="headerlink" title="Servlet Cookie处理"></a>Servlet Cookie处理</h3><p>Cookie是存储在客户端计算机上的文本文件，并保留了各种跟踪信息。<br>识别返回用户包括三个步骤：<br>1、服务器脚本向浏览器发送一组Cookie。例如：姓名、年龄或识别号码等。<br>2、浏览器将这些信息存储在本地计算机上，以备将来使用。<br>3、当下一次浏览器向Web服务器发送任何请求时，浏览器会把这些Cookie信息发送到服务器，服务器将使用这些信息来识别用户。</p>
<p><strong>Servlet Cookie 处理需要对中文进行编码与解码，方法如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = java.net.URLEncoder.encode(<span class="string">"中文"</span>，<span class="string">"UTF-8"</span>);            <span class="comment">//编码</span></span><br><span class="line">String str = java.net.URLDecoder.decode(<span class="string">"编码后的字符串"</span>,<span class="string">"UTF-8"</span>);   <span class="comment">// 解码</span></span><br></pre></td></tr></table></figure>

<h4 id="Cookie-剖析"><a href="#Cookie-剖析" class="headerlink" title="Cookie 剖析"></a>Cookie 剖析</h4><p>Cookie通常设置在HTTP头信息中，Cookie剖析和Cookie方法列表在如下网址中：<br><strong>Servlet Cookie处理</strong> : <a href="https://www.runoob.com/servlet/servlet-cookies-handling.html" target="_blank" rel="noopener">https://www.runoob.com/servlet/servlet-cookies-handling.html</a></p>
<h4 id="通过Servlet设置Cookie"><a href="#通过Servlet设置Cookie" class="headerlink" title="通过Servlet设置Cookie"></a>通过Servlet设置Cookie</h4><p>通过Servlet设置Cookie包括三个步骤：<br><strong>1、创建一个Cookie对象</strong>：可以调用带有cookie名称和cookie值的Cookie构造函数，cookie名称和cookie值都是字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"key"</span>,<span class="string">"value"</span>);</span><br></pre></td></tr></table></figure>
<p>无论名字还是值，都不应该包含空格或以下任何字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ ] ( ) &#x3D; , &quot; &#x2F; ? @ : ;</span><br></pre></td></tr></table></figure>

<p><strong>2、设置最大生存周期</strong>：可以使用setMaxAge方法来指定cookie能够保持有效的时间(以秒为单位)。下面将设置一个最长有效期为24小时的cookie。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cookie.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>);</span><br></pre></td></tr></table></figure>

<p><strong>3、发送Cookie到HTTP响应头</strong>：可以使用response.addCookie来添加HTTP响应头中的Cookie，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<p>为名字和姓氏<strong>设置Cookie</strong>的例子如下所示，在doGet()中实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 为名字和姓氏创建 Cookie      </span></span><br><span class="line">        Cookie name = <span class="keyword">new</span> Cookie(<span class="string">"name"</span>, URLEncoder.encode(request.getParameter(<span class="string">"name"</span>), <span class="string">"UTF-8"</span>)); <span class="comment">// 中文转码</span></span><br><span class="line">        Cookie url = <span class="keyword">new</span> Cookie(<span class="string">"url"</span>, request.getParameter(<span class="string">"url"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为两个 Cookie 设置过期日期为 24 小时后</span></span><br><span class="line">        name.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>); </span><br><span class="line">        url.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在响应头中添加两个 Cookie</span></span><br><span class="line">        response.addCookie( name );</span><br><span class="line">        response.addCookie( url );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过Servlet读取Cookie"><a href="#通过Servlet读取Cookie" class="headerlink" title="通过Servlet读取Cookie"></a>通过Servlet读取Cookie</h4><p>要读取Cookie，需要通过调用HttpServletRequest的<strong>getCookies()</strong>方法来创建一个javax.servlet.http.Cookie对象的数组。然后循环遍历数组，并使用<strong>getName()</strong>和<strong>getValue()</strong>方法来访问每个Cookie和关联的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">null</span>;</span><br><span class="line">Cookie[] cookies = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 获取与该域相关的 Cookie 的数组</span></span><br><span class="line">cookies = request.getCookies();</span><br><span class="line"><span class="keyword">if</span>( cookies != <span class="keyword">null</span> )&#123;</span><br><span class="line">    out.println(<span class="string">"&lt;h2&gt;Cookie 名称和值&lt;/h2&gt;"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cookies.length; i++)&#123;</span><br><span class="line">        cookie = cookies[i];</span><br><span class="line">        <span class="keyword">if</span>((cookie.getName( )).compareTo(<span class="string">"name"</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">            cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">            response.addCookie(cookie);</span><br><span class="line">            out.print(<span class="string">"已删除的 cookie："</span> + cookie.getName( ) + <span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(<span class="string">"名称："</span> + cookie.getName( ) + <span class="string">"，"</span>);</span><br><span class="line">        out.print(<span class="string">"值："</span> +  URLDecoder.decode(cookie.getValue(), <span class="string">"utf-8"</span>) +<span class="string">" &lt;br/&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    out.println(<span class="string">"&lt;h2 class=\"tutheader\"&gt;No Cookie founds&lt;/h2&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过Servlet删除Cookie"><a href="#通过Servlet删除Cookie" class="headerlink" title="通过Servlet删除Cookie"></a>通过Servlet删除Cookie</h4><p>删除Cookie是非常简单的，如果想删除一个cookie，只需要按照以下三个步骤进行：<br><strong>1、读取一个现有的cookie，并把它存储在Cookie对象中.</strong><br><strong>2、使用setMaxAge()方法设置cookie的年龄为0，来删除现有的cookie。</strong><br><strong>3、把这个cookie添加到响应头。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">null</span>;</span><br><span class="line">Cookie[] cookies = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 获取与该域相关的 Cookie 的数组</span></span><br><span class="line">cookies = request.getCookies();</span><br><span class="line"><span class="keyword">if</span>( cookies != <span class="keyword">null</span> )&#123;</span><br><span class="line">    out.println(<span class="string">"&lt;h2&gt;Cookie 名称和值&lt;/h2&gt;"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cookies.length; i++)&#123;</span><br><span class="line">        cookie = cookies[i];</span><br><span class="line">        <span class="keyword">if</span>((cookie.getName( )).compareTo(<span class="string">"url"</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">            cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">            response.addCookie(cookie);</span><br><span class="line">            out.print(<span class="string">"已删除的 cookie："</span> + cookie.getName( ) + <span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(<span class="string">"名称："</span> + cookie.getName( ) + <span class="string">"，"</span>);</span><br><span class="line">        out.print(<span class="string">"值："</span> + cookie.getValue( )+<span class="string">" &lt;br/&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    out.println(<span class="string">"&lt;h2 class=\"tutheader\"&gt;No Cookie founds&lt;/h2&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Servlet-Session-跟踪"><a href="#Servlet-Session-跟踪" class="headerlink" title="Servlet Session 跟踪"></a>Servlet Session 跟踪</h3><p>HTTP 是一种”无状态”协议，这意味着每次客户端检索网页时，客户端打开一个单独的连接到 Web 服务器，服务器会自动<strong>不保留</strong>之前客户端请求的任何记录。<br>但是仍然有以下三种方式来维持Web客户端和Web服务器之间的session会话，分别是<strong>Cookies、隐藏的表单字段和URL重写。</strong></p>
<h4 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h4><p>一个 Web 服务器可以分配一个唯一的session会话ID作为每个Web客户端的cookie，对于客户端的后续请求可以使用接收到的cookie来识别。<strong>这可能不是一个有效的方法</strong>，因为很多浏览器不支持cookie，所以我们建议不要使用这种方式来维持session会话。</p>
<h4 id="隐藏的表单字段"><a href="#隐藏的表单字段" class="headerlink" title="隐藏的表单字段"></a>隐藏的表单字段</h4><p>一个Web服务器可以发送一个隐藏的HTML表单字段，以及一个唯一的session会话ID，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"hidden"</span> name=<span class="string">"sessionid"</span> value=<span class="string">"12345"</span>&gt;</span><br></pre></td></tr></table></figure>
<p><strong>当表单被提交时，指定的名称和值会被自动包含在GET或POST数据中，每次当Web浏览器发送回请求时，session_id值可以用于保持不同的Web浏览器的跟踪。</strong>这可能是一种保持session会话跟踪的有效方式，但是点击常规的超文本链接不会导致表单提交，因此隐藏的表单字段也不支持常规的session会话跟踪。</p>
<h4 id="URL重写"><a href="#URL重写" class="headerlink" title="URL重写"></a>URL重写</h4><p>可以<strong>在每个URL末尾追加一些额外的数据</strong>来标识session会话，服务器会把该session会话标识符与已存储的有关 session 会话的数据相关联.</p>
<h4 id="HTTPSession-对象"><a href="#HTTPSession-对象" class="headerlink" title="HTTPSession 对象"></a>HTTPSession 对象</h4><p>Servlet还提供了<strong>HttpSession接口</strong>，该接口提供了一种跨多个页面请求或访问网站时识别用户以及存储有关用户信息的方式。Servlet容器使用这个接口来<strong>创建一个HTTP客户端和HTTP服务器之间的session会话</strong>，会话持续一个指定的时间段，跨多个连接或页面请求。<br>通过调用<strong>HttpServletRequest的公共方法getSession()</strong>来获取HttpSession对象，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br></pre></td></tr></table></figure>
<p>需要在向客户端发送任何文档内容之前调用request.getSession()。HttpSession对象中可用的几个重要方法在如下地址中：<br><strong>菜鸟教程-HttpSession对象</strong> : <a href="https://www.runoob.com/servlet/servlet-session-tracking.html" target="_blank" rel="noopener">https://www.runoob.com/servlet/servlet-session-tracking.html</a></p>
<h4 id="Session跟踪实例"><a href="#Session跟踪实例" class="headerlink" title="Session跟踪实例"></a>Session跟踪实例</h4><p>本实例说明了如何使用HttpSession对象获取session会话创建时间和最后访问时间。如果不存在session会话，将通过请求创建一个新的session会话。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果不存在 session 会话，则创建一个 session 对象</span></span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 获取 session 创建时间</span></span><br><span class="line">Date createTime = <span class="keyword">new</span> Date(session.getCreationTime());</span><br><span class="line"><span class="comment">// 获取该网页的最后一次访问时间</span></span><br><span class="line">Date lastAccessTime = <span class="keyword">new</span> Date(session.getLastAccessedTime());</span><br><span class="line">         </span><br><span class="line"><span class="comment">//设置日期输出的格式  </span></span><br><span class="line">SimpleDateFormat df=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">String title = <span class="string">"Servlet Session 实例 - 菜鸟教程"</span>;</span><br><span class="line">Integer visitCount = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">String visitCountKey = <span class="keyword">new</span> String(<span class="string">"visitCount"</span>);</span><br><span class="line">String userIDKey = <span class="keyword">new</span> String(<span class="string">"userID"</span>);</span><br><span class="line">String userID = <span class="keyword">new</span> String(<span class="string">"Runoob"</span>);</span><br><span class="line"><span class="keyword">if</span>(session.getAttribute(visitCountKey) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    session.setAttribute(visitCountKey, <span class="keyword">new</span> Integer(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 检查网页上是否有新的访问者</span></span><br><span class="line"><span class="keyword">if</span> (session.isNew())&#123;</span><br><span class="line">    title = <span class="string">"Servlet Session 实例 - 菜鸟教程"</span>;</span><br><span class="line">    session.setAttribute(userIDKey, userID);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    visitCount = (Integer)session.getAttribute(visitCountKey);</span><br><span class="line">    visitCount = visitCount + <span class="number">1</span>;</span><br><span class="line">    userID = (String)session.getAttribute(userIDKey);</span><br><span class="line">&#125;</span><br><span class="line">session.setAttribute(visitCountKey,  visitCount);</span><br><span class="line"></span><br><span class="line">session.getId();    <span class="comment">//获得ID，visitCount是访问统计数量</span></span><br></pre></td></tr></table></figure>

<h4 id="删除Session会话数据"><a href="#删除Session会话数据" class="headerlink" title="删除Session会话数据"></a>删除Session会话数据</h4><p>当完成了一个用户的session会话数据，有以下几种选择：<br><strong>·移除一个特定的属性</strong>：可以调用<strong>public void removeAttribute(String name)</strong>方法来删除与特定的键相关联的值。<br><strong>·删除整个session会话</strong>：可以调用<strong>public void invalidate()</strong>方法来丢弃整个session会话。<br><strong>·设置session会话过期时间</strong>：可以调用<strong>public void setMaxInactiveInterval(int interval)</strong>方法来单独设置session会话超时。<br><strong>·注销用户</strong>：如果使用的是支持servlet 2.4的服务器，可以调用<strong>logout</strong>来注销 Web服务器的客户端，并把属于所有用户的所有session会话设置为无效。<br><strong>web.xml配置</strong>：如果使用的是Tomcat，可以在web.xml文件中配置session会话超时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;session-config&gt;</span><br><span class="line">  &lt;session-timeout&gt;15&lt;&#x2F;session-timeout&gt;   &#x2F;&#x2F;超时时间单位是分钟</span><br><span class="line">&lt;&#x2F;session-config&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Servlet实现账号密码登录"><a href="#Servlet实现账号密码登录" class="headerlink" title="Servlet实现账号密码登录"></a>Servlet实现账号密码登录</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span>&#123;</span><br><span class="line"></span><br><span class="line">        request.setCharacterEncoding(<span class="string">"UTF-8"</span>);/</span><br><span class="line">        response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.SignIn(request, response) == <span class="keyword">true</span>)&#123;</span><br><span class="line">            request.getRequestDispatcher(<span class="string">"/SignIn_success.jsp"</span>).forward(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            request.getRequestDispatcher(<span class="string">"/SignIn_fail.jsp"</span>).forward(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Boolean <span class="title">SignIn</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span>&#123;</span><br><span class="line">        UserDAO userDAO = <span class="keyword">new</span> UserDAO();</span><br><span class="line">        String account = request.getParameter(<span class="string">"account"</span>);</span><br><span class="line">        String password = request.getParameter(<span class="string">"password"</span>);</span><br><span class="line">        ArrayList&lt;User&gt; userList = userDAO.getAllUser();  <span class="comment">//获得数据库所有的User</span></span><br><span class="line">        <span class="keyword">for</span>(User user : userList)&#123;</span><br><span class="line">            <span class="keyword">if</span>(account.equals(user.getAccount()))&#123;</span><br><span class="line">                <span class="keyword">if</span>(password.equals(user.getPassword()))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中<strong>request.getRequestDispatcher(“/SignIn_success.jsp”).forward(request, response);</strong> 方法是跳转页面到SignIn_success.jsp。</p>
<p>html提交表单的页面代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span> = <span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录界面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"UserAction"</span> <span class="attr">method</span>=<span class="string">"GET"</span>&gt;</span></span><br><span class="line">    账号: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"account"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    密码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">name</span> = <span class="string">"password"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"submit"</span> <span class="attr">value</span> = <span class="string">"登录"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中的action后的值，要对应映射的servlet的名称，同时也要和web.xml中servlet映射的名称相同，才不会出现错误。</p>
]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2020/07/05/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类是定义在一个另一个类中的类<br><strong>1、内部类可以对同一个包中的其他类隐藏</strong><br><strong>2、内部类方法可以访问定义这个类的作用域中的数据，包括原本私有的数据</strong></p>
<p>在Java中，可以将一个类定义在<strong>另一个类里面</strong>或者<strong>一个方法里面</strong>，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：<strong>成员内部类、局部内部类、匿名内部类和静态内部类</strong>。</p>
<h4 id="1、成员内部类"><a href="#1、成员内部类" class="headerlink" title="1、成员内部类"></a>1、成员内部类</h4><p>成员内部类是最普通的内部类，它的定义位于另一个类的内部，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"drawshape"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员变量和成员方法(包括private成员和静态成员)。<strong>注意：当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类.<span class="keyword">this</span>.成员变量</span><br><span class="line">外部类.<span class="keyword">this</span>.成员方法</span><br></pre></td></tr></table></figure>
<p><strong>这是在内部类的方法中访问外部类相同名称成员变量和成员方法的时候</strong>，如下图所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">double</span> radius;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Draw</span><span class="params">(<span class="keyword">double</span> radius)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Circle中的radiu: "</span> + Circle.<span class="keyword">this</span>.radius); <span class="comment">//访问外部类中同名的变量</span></span><br><span class="line">            System.out.println(<span class="string">"Draw中的radius: "</span> + radius); <span class="comment">//访问内部类中的变量</span></span><br><span class="line">            System.out.println(count); <span class="comment">//访问外部类的静态变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部类要是想访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        getDrawInstance().drawSahpe();   <span class="comment">//必须先创建成员内部类的对象，再进行访问</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Draw <span class="title">getDrawInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Draw();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(Circle.count);</span><br><span class="line">        Circle outter = <span class="keyword">new</span> Circle(<span class="number">5</span>);</span><br><span class="line">        Circle.Draw inner = outter.<span class="keyword">new</span> Draw(<span class="number">10</span>);</span><br><span class="line">        inner.draw();</span><br><span class="line">        System.out.println(inner.radius);</span><br><span class="line">        System.out.println(outter.radius);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、局部内部类"><a href="#2、局部内部类" class="headerlink" title="2、局部内部类"></a>2、局部内部类</h4><p>局部内部类是定义在<strong>一个方法</strong>或者<strong>一个作用域里面</strong>的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;   <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="keyword">int</span> age =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Woman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：局部内部类就像是方法里的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</strong></p>
<h4 id="3、匿名内部类"><a href="#3、匿名内部类" class="headerlink" title="3、匿名内部类"></a>3、匿名内部类</h4><p>匿名内部类应该是平时编写代码时用的最多的，一般是定义接口对象时使用，可以与lambda表达式相互转换。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123;      <span class="comment">//匿名内部类，实现Runnable接口的run()函数</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程启动了！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        runnable.run();</span><br></pre></td></tr></table></figure>
<p><strong>匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</strong></p>
<h4 id="4、静态内部类"><a href="#4、静态内部类" class="headerlink" title="4、静态内部类"></a>4、静态内部类</h4><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Outter.Inner inner = <span class="keyword">new</span> Outter.Inner();  <span class="comment">//静态内部类的创建不需要首先创建外部类的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;   <span class="comment">//静态内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(a);   <span class="comment">//出错，不能访问外部类普通变量</span></span><br><span class="line">            System.out.println(b);   <span class="comment">//正确，可以访问外部类静态变量 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参考博客</strong><br>Java内部类详解 - Matrix海子 - 博客园：<a href="https://www.cnblogs.com/dolphin0520/p/3811445.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3811445.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>lambada表达式</title>
    <url>/2020/07/04/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。</p>
<p><strong>lambda表达式离不开接口！！！这个lambda表达式，是需要函数式接口支持的，函数式接口，即只包含一个抽象方法的接口。</strong></p>
<p>判断一个接口是不是函数式接口，我们可以在任意函数式接口上使@FunctionalInterface注解，这样做可以检查它是否是一个函数式接口，还可以通过查看这个接口的内部实现，若是在开头有一个 <strong>@FunctionalInterface</strong> 的注解，则表示这个接口是函数式接口,如下图Runnable接口所示</p>
<p><img src="/2020/07/04/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/1.jpg" alt></p>
<p><strong>我们可以通过lambda表达式来创建该接口的对象(若lambda表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明)。</strong></p>
<h3 id="lambda表达式的语法"><a href="#lambda表达式的语法" class="headerlink" title="lambda表达式的语法"></a>lambda表达式的语法</h3><p>Java中的一种lambda表达式形式：<strong>参数，箭头(-&gt;)以及一个表达式</strong>，如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在大括号{}中，并包含显示的return语句。</p>
<p>箭头(-&gt;)操作符把lambda表达式分为两部分：<br><strong>左侧：lambda表达式的参数列表</strong><br><strong>右侧：lambda表达式中所需执行的功能，即lambda体</strong></p>
<p>例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里用到了Runnable接口，这个接口的函数是run()</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种情况，使用匿名类实现Runnable接口的run函数</span></span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程启动了！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        runnable.run();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种情况，使用lambda表达式来实现Runnable接口的run函数，注意只是实现函数，没有执行函数，还要另外执行</span></span><br><span class="line">        Runnable runnable1 = () -&gt; System.out.println(<span class="string">"线程1启动了"</span>);</span><br><span class="line">        runnable1.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此例中，给Runnable接口实例化，第一种方法使用内部类，第二种方法采用了lambda表达式。<strong>注意，这两种方法都只是实现了接口中的方法，并没有调用方法，若是想调用方法还需在实例对象中调用。使用内部类，里面有接口中方法的完整实现，使用lambda表达式，箭头(-&gt;)右边的语句就等同于实现run()方法中的语句。</strong></p>
<h4 id="语法格式1：无参数，无返回值"><a href="#语法格式1：无参数，无返回值" class="headerlink" title="语法格式1：无参数，无返回值"></a>语法格式1：无参数，无返回值</h4><p>无参数的时候，<strong>括号不能省略</strong>，如上述例子所示，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable runnable1 = () -&gt; System.out.println(<span class="string">"线程1启动了"</span>);</span><br></pre></td></tr></table></figure>
<p>结果如下图所示：</p>
<p><img src="/2020/07/04/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%5C2.jpg" alt></p>
<h4 id="语法格式2：无参数，有返回值"><a href="#语法格式2：无参数，有返回值" class="headerlink" title="语法格式2：无参数，有返回值"></a>语法格式2：无参数，有返回值</h4><p>括号不能省略，若是只有一条返回语句，可以省略return，程序示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里使用的是Supplier接口，要实现的函数是 T get()</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Supplier supplier = <span class="keyword">new</span> Supplier() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;  <span class="comment">//get()函数的返回值类型是Object，而这里返回的是String类型，是object的子类</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"532146"</span>.substring(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda表达式只是实现了get()函数，并且省略了return，实际上返回了"532146".substring(1, 5)</span></span><br><span class="line">        <span class="comment">//而Supplier后面省略了String类型</span></span><br><span class="line">        Supplier supplier1 = () -&gt; <span class="string">"532146"</span>.substring(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(supplier1.get());</span><br><span class="line"></span><br><span class="line">        Supplier&lt;String&gt; supplier2 = () -&gt; <span class="string">"532146"</span>.substring(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(supplier2.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下图所示：</p>
<p><img src="/2020/07/04/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%5C7.jpg" alt></p>
<h4 id="语法格式3：有一个参数，并且无返回值"><a href="#语法格式3：有一个参数，并且无返回值" class="headerlink" title="语法格式3：有一个参数，并且无返回值"></a>语法格式3：有一个参数，并且无返回值</h4><p>有一个参数的时候，可以省略括号，也可以不省略括号，示例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer1 = e -&gt; System.out.println(<span class="string">"liweian2 is "</span> + e);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Consumer&lt;String&gt; consumer2 = (String f) -&gt; System.out.println(<span class="string">"liweian3 is "</span> + f);</span><br></pre></td></tr></table></figure>
<p><strong>这里需要注意的是，箭头(-&gt;)左侧是参数，当这个接口的方法需要参数时，才需要参数。同时，当前面接口的类型存在时，参数的类型会自动检测，可写可不写，当写上参数类型时，需要加括号</strong></p>
<p>程序示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里用到了Consumer接口，这个接口的函数是accept(T t)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意到，使用匿名类来实现Consumer接口函数时，由于在accept参数中声明了String类，所以必须在Consumer</span></span><br><span class="line">        <span class="comment">//后面声明String类</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"liweian is "</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer.accept(<span class="string">"ok!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Consumer后加了String类型后，参数e就可以自动检测类型</span></span><br><span class="line">        <span class="comment">//lambda表达式只是实现了接口的函数，并没有调用</span></span><br><span class="line">        Consumer&lt;String&gt; consumer1 = e -&gt; System.out.println(<span class="string">"liweian2 is "</span> + e);</span><br><span class="line">        consumer1.accept(<span class="string">"ok!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若是使用lambda表达式，且给accept参数f标明了是String类型，则要在Consumer后面写出String类型</span></span><br><span class="line">        Consumer&lt;String&gt; consumer2 = (String f) -&gt; System.out.println(<span class="string">"liweian3 is "</span> + f);</span><br><span class="line">        consumer2.accept(<span class="string">"ok!"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2020/07/04/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%5C3.jpg" alt></p>
<h4 id="语法格式4：有一个参数，并且有返回值"><a href="#语法格式4：有一个参数，并且有返回值" class="headerlink" title="语法格式4：有一个参数，并且有返回值"></a>语法格式4：有一个参数，并且有返回值</h4><p>这种类型的lambda表达式其实和上一种一样，return并不用写出来，直接就是返回值，程序示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//匿名类</span></span><br><span class="line">        Function&lt;String, String&gt; function = <span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> e.substring(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">"liweian"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        Function&lt;String, String&gt; function1 = (String x) -&gt; x.substring(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(function1.apply(<span class="string">"liweian"</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意下面的lambda表达式，并没有return语句，但是返回了x.substring(1, 4)，同时，可以注意到Function&lt;String, String&gt;，可以通过查看Function接口的实现知道，前一个是输入参数的类型，后一个是返回参数的类型，同时输入参数的返回值可以省略。</strong><br>Function接口的定义如下图所示：</p>
<p><img src="/2020/07/04/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%5C4.jpg" alt></p>
<p>程序运行的结果如下图所示：</p>
<p><img src="/2020/07/04/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%5C5.jpg" alt></p>
<h4 id="语法格式5：有两个以上的参数，有返回值，并且lambda体中有多条语句"><a href="#语法格式5：有两个以上的参数，有返回值，并且lambda体中有多条语句" class="headerlink" title="语法格式5：有两个以上的参数，有返回值，并且lambda体中有多条语句"></a>语法格式5：有两个以上的参数，有返回值，并且lambda体中有多条语句</h4><p>当lambda表达式有多条语句的时候，箭头(-&gt;)右边需要{}括起来，且有返回值的时候需要return。程序示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里使用Comparator接口，实现的函数是 int compare(T o1, T o2)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer x, Integer y)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"函数式接口1"</span>);</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(comparator.compare(<span class="number">100</span>, <span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用lambda表达式，如果内容是多条语句，要用&#123;&#125;括起来，注意这里Comparator后必须加Integer类型</span></span><br><span class="line">        <span class="comment">//因为函数体里的Integer.compare()函数要int类型</span></span><br><span class="line">        Comparator&lt;Integer&gt; comparator1 = (x1, y1) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"函数式接口2"</span>);</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(x1, y1);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(comparator1.compare(<span class="number">100</span>, <span class="number">200</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下图所示：</p>
<p><img src="/2020/07/04/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%5C6.jpg" alt></p>
<h4 id="语法格式6：有多个参数，但是lambda表达式只有一条语句，且有返回值"><a href="#语法格式6：有多个参数，但是lambda表达式只有一条语句，且有返回值" class="headerlink" title="语法格式6：有多个参数，但是lambda表达式只有一条语句，且有返回值"></a>语法格式6：有多个参数，但是lambda表达式只有一条语句，且有返回值</h4><p>此时return和大括号({})都可以省略不写，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Comparator&lt;Integer&gt; comparator2 = (x2, y2) -&gt; Integer.compare(x2, y2);</span><br><span class="line">        System.out.println(comparator2.compare(<span class="number">100</span>, <span class="number">200</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java内置的四大函数式接口"><a href="#Java内置的四大函数式接口" class="headerlink" title="Java内置的四大函数式接口"></a>Java内置的四大函数式接口</h3><table>
<thead>
<tr>
<th align="center">函数式接口</th>
<th align="center">参数类型</th>
<th align="center">返回类型</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Consumer&lt; T &gt; 消费型接口</td>
<td align="center">T</td>
<td align="center">void</td>
<td align="center">对类型为T的对象应用操作，包含方法：void accept(T t)</td>
</tr>
<tr>
<td align="center">Supplier&lt; T &gt; 供给型接口</td>
<td align="center">无</td>
<td align="center">T</td>
<td align="center">返回类型为T的对象，包含方法：T get()</td>
</tr>
<tr>
<td align="center">Function&lt;T, R&gt; 函数型接口</td>
<td align="center">T</td>
<td align="center">R</td>
<td align="center">对类型为T的对象应用操作，并返回结果，结果是R类型的对象，包含方法：R apply(T t)</td>
</tr>
<tr>
<td align="center">Predicate&lt; T &gt; 断定型接口</td>
<td align="center">T</td>
<td align="center">boolean</td>
<td align="center">确定类型为T的对象是否满足某约束，并返回boolean类型，包含方法：boolean test(T t)</td>
</tr>
</tbody></table>
<p>前面三个都已经演示过了，只剩下Predicate接口没有演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里使用的接口是Predicate&lt;T t&gt;, 实现的函数是boolean test(T t)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = <span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> e.length() &gt; <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">"liweian"</span>));</span><br><span class="line">        System.out.println(predicate.test(<span class="string">"abc"</span>));</span><br><span class="line"></span><br><span class="line">        Predicate&lt;String&gt; predicate1 = (String x) -&gt; x.length() &gt; <span class="number">5</span>;</span><br><span class="line">        System.out.println(predicate1.test(<span class="string">"liweian"</span>));</span><br><span class="line">        System.out.println(predicate1.test(<span class="string">"abc"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里Predicate后必须加String，而lambda表达式中的y的String类型可以自动判断出</span></span><br><span class="line">        Predicate&lt;String&gt; predicate2 = y -&gt; y.length() &gt; <span class="number">5</span>;</span><br><span class="line">        System.out.println(predicate2.test(<span class="string">"liweian"</span>));</span><br><span class="line">        System.out.println(predicate2.test(<span class="string">"abc"</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下图所示：</p>
<p><img src="/2020/07/04/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%5C8.jpg" alt></p>
<h3 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h3><p><strong>当要传递给lambda体的操作，已经有实现的方法了，可以使用方法引用</strong> ,方法引用就是lambda表达式，或者说是代替lambda表达式。<br>这句话是什么意思呢，举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用匿名类</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer x, Integer y)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambda表达式</span></span><br><span class="line">System.out.println(comparator.compare(<span class="number">100</span>, <span class="number">200</span>));</span><br><span class="line">Comparator&lt;Integer&gt; comparator2 = (x2, y2) -&gt; Integer.compare(x2, y2);</span><br><span class="line">System.out.println(comparator2.compare(<span class="number">100</span>, <span class="number">200</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法引用</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator3 = Integer::compare;</span><br><span class="line">System.out.println(comparator3.compare(<span class="number">100</span>, <span class="number">200</span>));</span><br></pre></td></tr></table></figure>
<p>此例中在实现compare方法时，调用了Integer.compare()方法，这是一个已经实现了的方法，因此可以用方法引用代替lambda表达式</p>
<p><strong>注意：实现抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！</strong><br>这里意思是，比如方法引用中的方法是<strong>int Integer.compare(Integer x, Integer y)</strong>方法，它的参数是两个Integer类型，返回值是int类型，而实现的接口的抽象方法是Comparator&lt; T &gt;的<strong>int compare(T o1, T o2)</strong> 方法，也是两个参数，参数类型由Comparator类型决定，返回值也是int类型，因此可以方法引用。</p>
<p>方法引用：使用操作符 <strong>“::”</strong> 将类(或对象) 与 方法名分隔开来。</p>
<p>如下三种主要使用情况：<br><strong>对象::实例方法名</strong><br><strong>类::静态方法名</strong><br><strong>类::实例方法名</strong></p>
<p>运行结果如下图所示：</p>
<p><img src="/2020/07/04/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%5C9.jpg" alt></p>
<p><strong>参考博客</strong><br>java农民工——java8新特性之lambda表达式的使用：<a href="https://www.cnblogs.com/nnxud/p/9827704.html" target="_blank" rel="noopener">https://www.cnblogs.com/nnxud/p/9827704.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Java接口</title>
    <url>/2020/06/23/Java%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口用来描述类应该做什么，而不指定它们具体应该如何做。在Java程序设计语言中，接口不是类，而是对希望符合这个接口的类的一组需求。</p>
<p>接口中的所有方法都自动是public方法，因此，在接口<strong>声明方法</strong>时，不必提供关键字public。不过，在接口<strong>实现方法</strong>时，必须把方法声明为public。</p>
<p>提供实例字段和方法实现的任务应该由实现接口的那个类来完成，因此，可以将接口看成是<strong>没有实例字段</strong>的抽象类。</p>
<p><strong>为了让类实现一个接口，通常需要完成下面两个步骤：</strong><br>1、将类声明为实现给定的接口。<br>2、对接口中的所有方法提供定义。</p>
<p>比如，Arrays类中的sort方法承诺可以对对象数组进行排序，但要满足对象所属的类必须实现Comparable接口。这是因为，要对一个对象数组进行排序，必须要提供对象的<strong>比较方式</strong>。接口的定义用关键字interface描述，Comparable接口的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>  //表示<span class="title">Comparable</span>接口的创建</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span></span>;  <span class="comment">//接口声明方法不加public</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要将类声明为实现某个接口，需要使用关键字<strong>implements</strong>，比如Employee类实现Comparable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br></pre></td></tr></table></figure>

<p>此类的方法实现例子如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object otherObject)</span>  <span class="comment">//实现接口要加public</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Employee other = (Employee)otherObject;</span><br><span class="line">    <span class="keyword">return</span> Double.compare(salary, other.salary);  <span class="comment">//比较两个对象薪水的大小，返回一个数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以为泛型Comparable接口提供一个类型参数，举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;  </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span>  <span class="comment">//实现接口要加public</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary, other.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用sort时，要向sort方法提供对象的比较方式，但是不能在Employee类中直接提供一个compareTo方法，而必须实现Comparable接口，这是因为Java程序设计语言是一种强类型语言，在调用方法的时候，编译器要能检查这个方法确实存在，这是因为在sort方法中可能会有下面这样的语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i].compareTo(a[j]) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//rearrange a[i] and a[j]</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器必须要确认a[i]一定有一个compareTo方法，如果a是一个声明了Comparable接口的对象数组时，就可以确保拥有compareTo方法，因为每个实现Comparable接口的类都必须提供compareTo方法的定义，<strong>如果声明了Comparable接口，却没有实现compareTo方法，就会报错</strong>。</p>
<p>与建立类的继承层次一样，也可以扩展接口。这里允许有多条接口链，从通用性较高的接口扩展到专用性较高的接口。例如，假如有一个名为Moveable的接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> //这是一个接口，接口里定义了<span class="title">move</span>函数</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，可以假设一个名为Powered的接口扩展了以上Moveable接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Powered</span> <span class="keyword">extends</span> <span class="title">Moveable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">milesPerGallon</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">double</span> SPEED_LIMIT = <span class="number">95</span>;  <span class="comment">//a public static final constant</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口中的字段总是public static final</p>
<p>实现两个接口，比如希望自己设计的类拥有克隆和比较的能力，只要实现这两个接口就可以了，可以使用逗号将想要实现的各个接口分隔开：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Comparable</span></span></span><br></pre></td></tr></table></figure>

<p><strong>每个类只能扩展一个类，但是每个类可以实现多个接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span>, <span class="title">Comparable</span>  //<span class="title">ERROR</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span> //<span class="title">OK</span></span></span><br></pre></td></tr></table></figure>

<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>默认方法：用<strong>default</strong>修饰符标记</p>
<p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义同样的方法，会发生默认方法冲突。</p>
<p>解决默认方法冲突<br><strong>1、超类优先：</strong> 如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。<br><strong>2、接口冲突：</strong> 如果一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型(不论是否是默认参数)相同的方法，子类必须覆盖这个方法来解决冲突。</p>
<h4 id="接口与回调"><a href="#接口与回调" class="headerlink" title="接口与回调"></a>接口与回调</h4><p>回调是一种常见的程序设计模式，在这种模式中，可以指定某个特定事件发生时应该采取的动作。<br>在java.swing包中有一个Timer类，可以构造定时器，需要设置一个时间间隔，并告诉定时器经过这个时间间隔需要做什么。<br>定时器需要知道调用哪一种方法，并要求传递的对象所属的类实现了java.awt包中的<strong>ActionListener接口</strong>，接口如下:<br>``java<br>public interface ActionListener  //此接口定义了actionPerformed函数<br>{</p>
<pre><code>void actionPerformed(ActionEvent event);</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">当到达指定的时间间隔时，定时器就调用actionPerformed方法。</span><br><span class="line">定义一个实现ActionListener接口的类，然后将想要执行的语句放在actionPerformed方法中。定义的类举例如下:</span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">class TimePrinter implements ActionListener</span><br><span class="line">&#123;</span><br><span class="line">    public void actionPerformed(ActionEvent event)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;At the tone, the time  is &quot; + Instant.ofEpochMilli(event.getWhen()));</span><br><span class="line">        ToolKit.getDefaultToolkit().beep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，构造这个类的一个对象，并将它传递给Timer构造器(定时器)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TimePrinter listener = <span class="keyword">new</span> TimePrinter(); <span class="comment">//构造刚刚创建的类对象</span></span><br><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>, listener);  <span class="comment">//将类对象传递给Timer定时器，第一个参数是时间间隔</span></span><br></pre></td></tr></table></figure>

<p>Timer构造器的第一个参数是一个时间间隔(单位是毫秒)，即经过多长时间通知一次，第二个参数是监听器对象，包含一定时间后要做的事情。<br>最后，启动定时器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<h3 id="博客参考"><a href="#博客参考" class="headerlink" title="博客参考"></a>博客参考</h3><p>接口可以理解为一种<strong>特殊的类</strong>，里面是由<strong>全局常量</strong>和<strong>公共的抽象方法</strong>所组成。接口是解决<strong>Java无法使用多继承</strong>的一种手段。我们可以直接把接口理解为抽象类，即接口中的方法必须<strong>全部是抽象方法</strong>，即只声明了方法却没有具体实现的方法。</p>
<p>####接口的特点<br>接口就像一个类，可以拥有方法和属性，但在接口中声明的方法是默认抽象的，<strong>即只有方法标识符，而没有方法体。</strong></p>
<p>一个接口就是描述一种能力，接口的作用就是告诉类，你要实现我这种接口所代表的功能，你就必须实现某些方法，只有这样我才承认你确实拥有该接口代表的某种能力。</p>
<p>如果一个类只有某个接口中的方法标识，而没有提供方法体，那么这个类一定是个抽象类。（必须记住：<strong>有抽象方法的类一定是抽象类，但是抽象类可以具有非抽象方法，即具体实现的方法，而接口是百分百的抽象类</strong>）</p>
<h4 id="为什么要用接口"><a href="#为什么要用接口" class="headerlink" title="为什么要用接口"></a>为什么要用接口</h4><p>1、接口被用来描述一种抽象<br>2、<strong>因为Java不支持多继承，所有Java可以通过实现接口来弥补这个局限</strong><br>3、接口也被用来实现解耦</p>
<p>接口被用来实现抽象，而抽象类也被用来实现抽象，为什么一定要用接口呢？接口和抽象类之间又有什么区别呢？<br><strong>原因是抽象类内部可能包含非final的变量，但是在接口中存在的变量一定是final, public, static的</strong></p>
<h4 id="关于接口的几个重点"><a href="#关于接口的几个重点" class="headerlink" title="关于接口的几个重点"></a>关于接口的几个重点</h4><p>1、<strong>我们不能直接去实例化一个接口</strong>，因为接口中的方法都是抽象的，是没有方法体的。怎么样才可以产生具体的实例呢？<strong>我们可以使用接口类型的引用指向一个实现了该接口的对象，并且可以调用这个接口中的方法</strong>，这实际上是使用了Java中多态的特性<br>(C++中的多态性，是使用虚基类和虚函数，给一个基类变量赋值一个子类的对象，这个基类变量调用基类中的方法的时候，就会直接调用子类中已经覆盖基类的方法，这就是多态性)<br>Java例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设USB是一个接口，而JianPan是一个实现了USB接口的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Usb</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JianPan</span> <span class="keyword">implements</span> <span class="title">Usb</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"键盘正在通过USB功能读取数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"键盘正在通过USB功能写入数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有实例化接口时</span></span><br><span class="line">JianPan jianpan = <span class="keyword">new</span> JianPan();</span><br><span class="line">jianpan.read();   <span class="comment">//调用键盘的read方法读取数据</span></span><br><span class="line">jianpan.write();</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化接口时，用到多态性</span></span><br><span class="line"></span><br><span class="line">Usb jianpan = <span class="keyword">new</span> JianPan();</span><br><span class="line">jianpan.read();    <span class="comment">//调用键盘的read方法读取数据</span></span><br><span class="line">jianpan.write();</span><br></pre></td></tr></table></figure>

<p>2、一个类可以实现不止一个接口。<br>3、一个接口可以继承于另一个接口，或者另一些接口，接口可以多继承。<br>4、一个类如果要实现某个接口的话，那么它必须要实现这个接口中的所有方法。<br>5、接口中的所有方法都是抽象的和public的，所有的属性都是public,static,final的。<br>6、接口用来弥补无法实现多继承的局限。<br>7、接口也可以用来实现解耦。</p>
<p><strong>我认为接口的存在是给类增加一些特定的功能，由于不想给原本的类的内部再增加多余的功能函数，使这个类越来越复杂，所以采取了类实现接口的方式，一个接口来对应一个功能函数，使这个类的对应功能清晰明了。同时因为Java不支持类的多继承，但是一个类可以实现多个接口，所以以实现多个接口来增加类的功能这个方法来代替类的多继承，这样就简单许多</strong></p>
<p><strong>参考博客</strong><br>JAVA基础——接口（全网最详细教程）：<a href="https://blog.csdn.net/qq_19782019/article/details/80259836" target="_blank" rel="noopener">https://blog.csdn.net/qq_19782019/article/details/80259836</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建遇到的问题</title>
    <url>/2020/03/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Hexo博客搭建遇到的问题"><a href="#Hexo博客搭建遇到的问题" class="headerlink" title="Hexo博客搭建遇到的问题"></a>Hexo博客搭建遇到的问题</h1><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><p><strong>前排提醒：配置更新和文件更新后博客没有变化，很可能是因为改动的配置文件和文章在编辑器中没有保存、没有保存、没有保存，所以运行hexo g后生成的静态文件没有变化 (重要的事情说三遍:可能没有保存)</strong></p>
<h3 id="1、运行hexo-g时出错"><a href="#1、运行hexo-g时出错" class="headerlink" title="1、运行hexo g时出错"></a>1、运行hexo g时出错</h3><p>运行hexo g时出错，基本上就是配置文件的语法出错了, 比如<strong>：</strong>，冒号后面要加一个空格，正确时如下图</p>
<p><img src="/2020/03/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/1.jpg" alt></p>
<p>错误的图如下</p>
<p><img src="/2020/03/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/2.jpg" alt></p>
<p>并且改完之后，一定要<strong>保存</strong>，然后再运行下面的代码，就基本正确了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<p>想要快速看到效果，则直接运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo s  &#x2F;&#x2F;开启本地服务器</span><br></pre></td></tr></table></figure>

<p>登录 <a href="https://bbigcat111.github.io/" target="_blank" rel="noopener">https://bbigcat111.github.io/</a> 查看效果，如果对了，就再次执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<p>成功后就可以登录github对应的网址查看博客的更新，有时候要多刷新几次。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建2</title>
    <url>/2020/03/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA2/</url>
    <content><![CDATA[<h1 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h1><h2 id="开始Github"><a href="#开始Github" class="headerlink" title="开始Github"></a>开始Github</h2><h3 id="1、创建Github账号"><a href="#1、创建Github账号" class="headerlink" title="1、创建Github账号"></a>1、创建Github账号</h3><p>要想部署到Github上，首先得有一个Github账号，现在前往<a href="https://github.com/" target="_blank" rel="noopener">Github官网</a>注册。</p>
<h3 id="2、创建一个github仓库-crerate-repository"><a href="#2、创建一个github仓库-crerate-repository" class="headerlink" title="2、创建一个github仓库(crerate repository)"></a>2、创建一个github仓库(crerate repository)</h3><p>假设你的github名称是test，则这个新建仓库的名称必须是<strong>test.github.io</strong>，必须是这个名称，其他的名称无效，部署成功以后访问 <a href="http://test.github.io" target="_blank" rel="noopener">http://test.github.io</a> 即可访问博客</p>
<h3 id="3、修改配置文件"><a href="#3、修改配置文件" class="headerlink" title="3、修改配置文件"></a>3、修改配置文件</h3><p>用软件(这里我用的是<strong>vscode</strong>)打开Hexo/blog目录下的_config.yml文件(前一章提及过)</p>
<p><img src="/2020/03/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA2/1.jpg" alt></p>
<p>下拉找到文件的最后，找到deploy，设置deploy信息，修改为如下</p>
<p><img src="/2020/03/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA2/2.jpg" alt></p>
<p>由于你的github名称是test，则这里repo的网址填 <a href="https://github.com/test/test.github.io" target="_blank" rel="noopener">https://github.com/test/test.github.io</a> , 如果最开始没有<strong>type</strong>、<strong>repo</strong>、<strong>branch</strong>自己补充，最终格式补充成上图中一样。</p>
<h3 id="4、设置SSH-Key"><a href="#4、设置SSH-Key" class="headerlink" title="4、设置SSH Key"></a>4、设置SSH Key</h3><p>如果不设置SSH Key，那么每次部署到github上都需要输入账号和密码，如果设置了SSH Key就不需要了。现在git bash上输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line">$ cd .ssh</span><br></pre></td></tr></table></figure>
<p>输入这两行代码是，进入根目录看有没有.ssh文件夹，若是设置了SSH Key就会在根目录产生.ssh文件夹，若是没有设置，则没有.ssh文件夹，会报错。</p>
<p>没有设置SSH Key，则添加一个，输入如下一条命令(如果有SSH Key跳过这一步)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ssh-keygen -t rsa -C &quot;your_email@mail.com&quot;   #&quot;your_email@mail.com&quot; 换成创建github时的邮箱号</span><br></pre></td></tr></table></figure>
<p>然后会提示你 Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): 可以<strong>只输入回车</strong>，此时在根目录会产生一个.shh文件夹，里面有两个文件<strong>id_rsa</strong>和<strong>id_rsa.pub</strong>。</p>
<p>回车之后,<strong>需要输入两次密码，第二次输入是确认密码</strong>(该密码是你push文件的时候要输入的密码，而不是github的密码)，该密码是隐形的，看不到。</p>
<h3 id="5、Github设置SSH-Key"><a href="#5、Github设置SSH-Key" class="headerlink" title="5、Github设置SSH Key"></a>5、Github设置SSH Key</h3><p>登录Github，点击右上角，选择<strong>Settings</strong>，然后在新页面的左边点击<strong>SSH and GPG keys</strong>，会进入下面的页面</p>
<p><img src="/2020/03/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA2/3.jpg" alt></p>
<p>再点击<strong>New SSH key</strong>，创建新的SSH key，点击后进入下面的页面</p>
<p><img src="/2020/03/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA2/4.jpg" alt></p>
<p>接下来打开<strong>C盘</strong>，<strong>用户</strong>文件夹里的.ssh文件夹，我电脑中的位置如下图</p>
<p><img src="/2020/03/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA2/5.jpg" alt></p>
<p>用<strong>记事本</strong>方式打开id_rsa.pub，复制里面的所有内容，拷贝到上图网站的key里，Title可以为空，然后点击<strong>Add SSH key</strong>以保存。</p>
<h3 id="6、测试SSH-key是否添加成功"><a href="#6、测试SSH-key是否添加成功" class="headerlink" title="6、测试SSH key是否添加成功"></a>6、测试SSH key是否添加成功</h3><p>git bash先进入Hexo/blog目录，然后在git bash输入一条指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>然后会出现一些警告，然后需要输入yes/no，输入yes，然后需要输入刚刚设置的密码，输入后运行，若是最后提示succeeful，则表示配置成功。</p>
<p><img src="/2020/03/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA2/7.jpg" alt></p>
<h3 id="7、部署到Github"><a href="#7、部署到Github" class="headerlink" title="7、部署到Github"></a>7、部署到Github</h3><p>在Hexo/blog目录下,依次输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g           &#x2F;&#x2F;对调整生成静态页面</span><br><span class="line">$ hexo d           &#x2F;&#x2F;部署到github</span><br></pre></td></tr></table></figure>
<p>等到命令执行完毕，若是最后出现Deploy done: git，则成功，如下图</p>
<p><img src="/2020/03/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA2/6.jpg" alt></p>
<p>现在就可以直接登录 <a href="http://test.github.io" target="_blank" rel="noopener">http://test.github.io</a> 进入博客啦！</p>
<p><strong>参考博客:</strong><br>admol: <a href="https://www.cnblogs.com/admol/p/admol.html" target="_blank" rel="noopener">https://www.cnblogs.com/admol/p/admol.html</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建1</title>
    <url>/2020/03/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA1/</url>
    <content><![CDATA[<h1 id="初步搭建"><a href="#初步搭建" class="headerlink" title="初步搭建"></a>初步搭建</h1><h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>是一款基于<strong>Node.js</strong>的静态博客框架，依赖少,易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。</p>
<h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><h3 id="1、安装Git"><a href="#1、安装Git" class="headerlink" title="1、安装Git"></a>1、安装Git</h3><p>Windows:前往<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git</a>官网下载软件，安装完成后有一个<strong>git bash</strong>的命令行工具，以后就使用这个工具来完成各种操作。</p>
<h3 id="2、安装Node-js"><a href="#2、安装Node-js" class="headerlink" title="2、安装Node.js"></a>2、安装Node.js</h3><p>由于Hexo是基于Node.js来编写的，所以需要前往官网安装<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js</a>,安装完成之后，在git bash里输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node -v</span><br></pre></td></tr></table></figure>
<p>若是显示版本号，就表示node.js安装成功。<br>同时，伴随着node.js的安装的有一个叫<strong>npm</strong>的包管理工具，安装完node.js后，在git bash输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm -v</span><br></pre></td></tr></table></figure>
<p>若是显示版本号，则表示npm安装成功</p>
<h3 id="3、安装Hexo"><a href="#3、安装Hexo" class="headerlink" title="3、安装Hexo"></a>3、安装Hexo</h3><p>在git bash中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure>
<p>安装完成后，在电脑的某个存储盘，创建一个名叫Hexo的文件夹，并建立一个子文件夹blog, 通过<strong>cd</strong>指令进入blog, 例如在我的电脑中cd进入blog文件夹</p>
<p><img src="/2020/03/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA1/1.jpg" alt></p>
<p>此时git bash已经进入到Hexo文件夹里的blog文件夹中,我们在git bash输入如下指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init    &#x2F;&#x2F;初始化hexo</span><br></pre></td></tr></table></figure>
<p>hexo会自动下载一些代码文件到这个目录</p>
<p><img src="/2020/03/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA1/2.jpg" alt></p>
<p>这里说明：source文件夹，存放的是写的文章之类的东西，themes文件夹，存放的是下载好的hexo博客主题，而_config.yml，是用来修改hexo博客的各种状态参数，以后会经常用到，我这里用vscode打开并且修改它。</p>
<h3 id="4、开启Hexo"><a href="#4、开启Hexo" class="headerlink" title="4、开启Hexo"></a>4、开启Hexo</h3><p>此时hexo最基础的部分已经搭建好了，通过上面的步骤，git bash已经在Hexo/blog的文件夹里, 我们先在git bash中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g    &#x2F;&#x2F;更新先前hexo博客所调整的所有内容，包括编写新文章和调整_config.yml文件里的某些参数</span><br></pre></td></tr></table></figure>
<p>完成之后继续输入以下指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo s     &#x2F;&#x2F;开启本地服务器</span><br></pre></td></tr></table></figure>
<p>输入后即开启本地服务器，如下图</p>
<p><img src="/2020/03/19/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA1/3.jpg" alt></p>
<p>现在本地服务器已经开始，打开网页，输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>  就可以进入博客啦，当然这时候的博客样式还是最初始的主题，我们可以通过后期更换主题来达到我们想要的效果。</p>
<p>当你要停止本地服务器，在git bash中输入<strong>ctrl + c</strong>即可关闭，此时再登录 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 已经不行了。想要再次进入，只有再次打开本地服务器。</p>
<h3 id="5、结尾"><a href="#5、结尾" class="headerlink" title="5、结尾"></a>5、结尾</h3><p>如果只进行到这一步，在网络上是不存在这个博客的，外界无法访问，还必须把它部署到github的一个新创建的特殊仓库里，部署完成后，才可以通过github仓库的提供的网址进入到你的博客里</p>
<p><strong>参考博客</strong><br>小茗同学的博客园：<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2019/12/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="Just-for-test"><a href="#Just-for-test" class="headerlink" title="Just for test"></a>Just for test</h2><p>2019年12月24日，我的Hexo博客搭建好了，接下来就是好好学习了不断记录新知识了，哈哈哈。。。。。。Markdown还不会呢</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
